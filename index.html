<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>자산 플래너</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-gradient@0.6.1/dist/chartjs-plugin-gradient.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        deposit: { 50: '#eff6ff', 500: '#3b82f6', 600: '#2563eb', start: '#60a5fa', end: '#3b82f6' },
                        savings: { 50: '#f0fdf4', 500: '#22c55e', 600: '#16a34a', start: '#34d399', end: '#10b981' },
                        investment: { 50: '#fff7ed', 500: '#f97316', 600: '#ea580c', start: '#fb923c', end: '#f97316' },
                        pension: { 50: '#faf5ff', 500: '#a855f7', 600: '#9333ea', start: '#c084fc', end: '#a855f7' },
                        realestate: { 50: '#fef7f0', 500: '#f59e0b', 600: '#d97706', start: '#fbbf24', end: '#f59e0b' },
                        car: { 50: '#ecfeff', 500: '#06b6d4', 600: '#0891b2', start: '#22d3ee', end: '#0891b2' },
                        loan: { 50: '#f3f4f6', 500: '#6b7280', 600: '#4b5563', start: '#9ca3af', end: '#6b7280' },
                        misc: { 50: '#f3f4f6', 500: '#6b7280', 600: '#4b5563', start: '#9ca3af', end: '#6b7280' }
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-gray-50">
    <div id="root"></div>

    <script>
        // ===== 기본값 설정 (서버/로컬 전환 가능) =====
        const USE_SERVER_CONFIG = false; // true: 서버에서 로드, false: 로컬 하드코딩 사용

        // 공개용 기본값 (제3자 공개 시 사용)
        const publicDefaultData = {
            projectionMonths: 12,
          monthlySalary: 280,
            targetAmount: 10000, // 목표 자산 금액 (만원)
            goalMode: 'period', // 'period' 또는 'target'
            displayMode: 'amount', // [추가] displayMode 기본값
            darkMode: false, // [추가] 다크 모드 상태
            rebalancingMode: 'simple', // 'simple' | 'advanced'
            assets: {
                deposit: [
                    { name: '비상금통장', amount: 100, rate: 2.0, feeRate: 0, monthlyContrib: 10, extraContrib: 0, extraFrom: '' },
                    { name: '생활비통장', amount: 30, rate: 2.0, feeRate: 0, monthlyContrib: 0, extraContrib: 0, extraFrom: '' },
                    { name: '카카오비상금', amount: 30, rate: 2.0, feeRate: 0, monthlyContrib: 0, extraContrib: 0, extraFrom: '' }
                ],
                savings: [
                    { name: '청년도약계좌', amount: 140, rate: 6.0, feeRate: 0, monthlyContrib: 0, extraContrib: 70, extraFrom: '비상금통장' },
                    { name: '청약저축', amount: 180, rate: 6.0, feeRate: 0, monthlyContrib: 10, extraContrib: 0, extraFrom: '' }
                ],
                investment: [
                    { name: '직접투자계좌', amount: 1400, rate: 10.0, feeRate: 0, monthlyContrib: 0, extraContrib: 0, extraFrom: '' },
                    { name: 'ISA계좌', amount: 500, rate: 10.0, feeRate: 0, monthlyContrib: 100, extraContrib: 0, extraFrom: '' },
                    { name: '금투자', amount: 0, rate: 3.0, feeRate: 0, monthlyContrib: 30, extraContrib: 0, extraFrom: '' },
                    { name: '비트코인', amount: 0, rate: 12.0, feeRate: 0, monthlyContrib: 15, extraContrib: 0, extraFrom: '' }
                ],
                pension: [
                    { name: '연금저축', amount: 199, rate: 10.0, feeRate: 0, monthlyContrib: 10, extraContrib: 0, extraFrom: '' }
                ],
                realestate: [
                    { name: '아파트', amount: 0, rate: 5.0, feeRate: 0, monthlyContrib: 0, extraContrib: 0, extraFrom: '' }
                ],
                car: [
                    { name: '자동차', amount: 70, rate: -2.0, feeRate: 0, monthlyContrib: 0, extraContrib: 0, extraFrom: '' }
                ],
                loan: [
                    { name: '신용대출', amount: 0, rate: 3.0, feeRate: 0, monthlyContrib: 0, extraContrib: 0, extraFrom: '' }
                ],
                misc: [
                    { name: '기타자산', amount: 0, rate: 2.0, feeRate: 0, monthlyContrib: 0, extraContrib: 0, extraFrom: '' }
                ]
            },
            monthlyExpenses: [
                { name: '생활비', amount: 100 }
            ],
            expenseEvents: [],
            rebalancingAlerts: {
                deposit: { warning: 5, danger: 10 },
                savings: { warning: 5, danger: 10 },
                investment: { warning: 5, danger: 10 },
                pension: { warning: 5, danger: 10 },
                realestate: { warning: 5, danger: 10 },
                misc: { warning: 5, danger: 10 }
            },
            simpleThresholds: { warning: 5, danger: 10 },
            rebalancingTargets: { /* 섹터별 목표 비중(%) 합계 100 */ },
            memo: '' // [추가] 메모 기능
        };

        
        // 서버 설정 로드 함수 (주석 처리/해제로 전환)
        async function loadServerConfig() {
            if (!USE_SERVER_CONFIG) return publicDefaultData;
            
            try {
                // const response = await fetch('/api/defaultconfig');
                // return await response.json();
                return publicDefaultData; // 서버 연결 실패시 기본값 사용
            } catch (error) {
                console.error('서버 설정 로드 실패:', error);
                return publicDefaultData;
            }
        }
    </script>

    <script type="text/babel">
            const { useState, useMemo, useEffect, useRef } = React;

        // [추가] 데이터 전송 모달 컴포넌트
        const DataTransferModal = ({ isOpen, onClose, onConfirm, type, initialSelection }) => {
            const [selectedItems, setSelectedItems] = useState(initialSelection || { appData: true, scenarios: true, assetHistory: true });

            const handleCheckboxChange = (e) => {
                setSelectedItems(prev => ({ ...prev, [e.target.name]: e.target.checked }));
            };

            const handleConfirm = () => {
                onConfirm(selectedItems);
                onClose();
            };

            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center z-50">
                    <div className="bg-white rounded-lg shadow-xl p-6 w-96">
                        <h3 className="text-lg font-semibold mb-4">{type === 'export' ? '데이터 내보내기' : '데이터 불러오기'}</h3>
                        <p className="text-sm text-gray-600 mb-4">
                            {type === 'export' ? '내보낼 데이터 항목을 선택하세요.' : '불러올 데이터 항목을 선택하세요. (기존 데이터는 덮어쓰여집니다.)'}
                        </p>
                        <div className="space-y-2 mb-6">
                            <label className="flex items-center">
                                <input type="checkbox" name="appData" checked={selectedItems.appData} onChange={handleCheckboxChange} className="mr-2" />
                                <span className="text-gray-800">기본 자산 데이터 (계좌, 지출, 이벤트, 메모 등)</span>
                            </label>
                            <label className="flex items-center">
                                <input type="checkbox" name="scenarios" checked={selectedItems.scenarios} onChange={handleCheckboxChange} className="mr-2" />
                                <span className="text-gray-800">저장된 시나리오</span>
                            </label>
                            <label className="flex items-center">
                                <input type="checkbox" name="assetHistory" checked={selectedItems.assetHistory} onChange={handleCheckboxChange} className="mr-2" />
                                <span className="text-gray-800">자산 히스토리</span>
                            </label>
                        </div>
                        <div className="flex justify-end space-x-3">
                            <button onClick={onClose} className="px-4 py-2 bg-gray-200 text-gray-800 rounded hover:bg-gray-300">취소</button>
                            <button onClick={handleConfirm} className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">확인</button>
                        </div>
                    </div>
                </div>
            );
        };

        // [추가] 패널 래퍼 컴포넌트
        const PanelWrapper = ({ id, title, moveUp, moveDown, isFirst, isLast, isCollapsed, onToggle, children }) => {
            return (
                <div id={id}>
                    <div className="flex justify-between items-center mb-4 cursor-pointer" onClick={onToggle}>
                        <h2 className="text-xl font-semibold text-gray-700 flex items-center gap-2 select-none">
                            <svg xmlns="http://www.w3.org/2000/svg" className={`h-5 w-5 text-gray-500 transform transition-transform duration-200 ${!isCollapsed ? 'rotate-90' : ''}`} viewBox="0 0 20 20" fill="currentColor">
                                <path fillRule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clipRule="evenodd" />
                            </svg>
                            {title}
                        </h2>
                        <div className="flex items-center gap-1">
                            <button 
                                onClick={(e) => {
                                    e.stopPropagation();
                                    moveUp();
                                }} 
                                disabled={isFirst}
                                className="p-1 rounded-full hover:bg-gray-200 disabled:opacity-30 disabled:cursor-not-allowed"
                                title="위로 이동"
                            >
                                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                    <path fillRule="evenodd" d="M14.707 12.707a1 1 0 01-1.414 0L10 9.414l-3.293 3.293a1 1 0 01-1.414-1.414l4-4a1 1 0 011.414 0l4 4a1 1 0 010 1.414z" clipRule="evenodd" />
                                </svg>
                            </button>
                            <button 
                                onClick={(e) => {
                                    e.stopPropagation();
                                    moveDown();
                                }} 
                                disabled={isLast}
                                className="p-1 rounded-full hover:bg-gray-200 disabled:opacity-30 disabled:cursor-not-allowed"
                                title="아래로 이동"
                            >
                                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                    <path fillRule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clipRule="evenodd" />
                                </svg>
                            </button>
                        </div>
                    </div>
                    {!isCollapsed && (
                        <div className="p-4 sm:p-6">
                            {children}
                        </div>
                    )}
                </div>
            );
        };

        // [추가] 리밸런싱 시각화를 위한 누적 막대 그래프 컴포넌트
        const StackedBarDisplay = ({ targets, sectorInfo }) => {
            const validSectors = Object.keys(sectorInfo).filter(k => k !== 'loan');
            const defaultPct = Math.round(100 / validSectors.length);
            
            const total = validSectors.reduce((sum, key) => {
                return sum + (targets[key] ?? defaultPct);
            }, 0);

            // 100% 기준으로 비율 재계산 (정규화)
            const normalizedTargets = validSectors.map(key => {
                const value = targets[key] ?? defaultPct;
                return {
                    key: key,
                    name: sectorInfo[key].name,
                    color: sectorInfo[key].color,
                    percentage: total === 0 ? 0 : (value / total) * 100,
                    originalValue: value
                };
            });

            return (
                <div className="w-full mb-4">
                    <div className="flex h-6 w-full rounded-full overflow-hidden border border-gray-300 dark:border-gray-600 bg-gray-200 dark:bg-gray-700">
                        {normalizedTargets.map(item => (
                            <div
                                key={item.key}
                                className={`flex items-center justify-center bg-${item.color}-500 transition-all duration-300`}
                                style={{ width: `${item.percentage}%` }}
                                title={`${item.name}: ${item.originalValue}%`}
                            >
                                <span className="text-xs font-medium text-white overflow-hidden whitespace-nowrap px-1">
                                    {item.percentage > 10 ? `${item.originalValue}%` : ''}
                                </span>
                            </div>
                        ))}
                    </div>
                    {total !== 100 && (
                        <div className="text-right text-xs text-red-600 dark:text-red-400 mt-1">
                            총합이 {total}%입니다. 100%로 조정해주세요.
                        </div>
                    )}
                </div>
            );
        };

        const AssetDashboard = () => {
            // ===== 모든 상태를 먼저 선언 =====
            const [appData, setAppData] = useState(null);
            const [scenarios, setScenarios] = useState([]);
            const [originalUserData, setOriginalUserData] = useState(null); // [추가] 원본 데이터 캐시
            const [isDemoMode, setIsDemoMode] = useState(false); // [추가] 데모 모드 상태
            const [goalSeekResult, setGoalSeekResult] = useState(null);
            const [mainCashFlowAccount, setMainCashFlowAccount] = useState('생활비통장');
            // 차트 ref들
            const currentPieRef = useRef(null);
            const projectedPieRef = useRef(null);
            const comparisonBarRef = useRef(null);
            const historyChartRef = useRef(null);
            // 섹터 접힘 상태는 항상 상단에서 선언하여 훅 순서 고정
            const [hiddenSectors, setHiddenSectors] = useState(() => {
                try {
                    const raw = localStorage.getItem('assetDashboardHiddenSectors');
                    return raw ? JSON.parse(raw) : {};
                } catch { return {}; }
            });
            useEffect(()=>{
                try {
                    localStorage.setItem('assetDashboardHiddenSectors', JSON.stringify(hiddenSectors));
                } catch {}
            }, [hiddenSectors]);

            // [추가] 데이터 전송 모달 상태
            const [isExportModalOpen, setIsExportModalOpen] = useState(false);
            const [isImportModalOpen, setIsImportModalOpen] = useState(false);
            const [exportSelection, setExportSelection] = useState({ appData: true, scenarios: true, assetHistory: true });
            const [importSelection, setImportSelection] = useState({ appData: true, scenarios: true, assetHistory: true });            
            // [추가] 레이아웃 순서 상태
            const [layoutOrder, setLayoutOrder] = useState(() => {
                try {
                    const savedOrder = localStorage.getItem('assetDashboardLayoutOrder');
                    return savedOrder ? JSON.parse(savedOrder) : ['summary', 'scenario', 'charts', 'history', 'budget', 'memo', 'rebalance', 'assets', 'expenses', 'events'];
                } catch {
                    return ['summary', 'scenario', 'charts', 'history', 'budget', 'memo', 'rebalance', 'assets', 'expenses', 'events'];
                }
            });
            useEffect(() => {
                localStorage.setItem('assetDashboardLayoutOrder', JSON.stringify(layoutOrder));
            }, [layoutOrder]);

            // [추가] 패널 접힘/펼침 상태
            const [panelCollapseState, setPanelCollapseState] = useState(() => {
                try {
                    const savedState = localStorage.getItem('assetDashboardPanelCollapse');
                    return savedState ? JSON.parse(savedState) : {}; // 기본값: 모두 펼침
                } catch {
                    return {};
                }
            });
            useEffect(() => {
                localStorage.setItem('assetDashboardPanelCollapse', JSON.stringify(panelCollapseState));
            }, [panelCollapseState]);


            // [추가] 자산 섹터 순서 상태
            const [assetSectorOrder, setAssetSectorOrder] = useState(() => {
                try {
                    const savedOrder = localStorage.getItem('assetDashboardAssetSectorOrder');
                    const defaultOrder = ['deposit', 'savings', 'investment', 'pension', 'realestate', 'car', 'loan', 'misc'];
                    return savedOrder ? JSON.parse(savedOrder) : defaultOrder;
                } catch {
                    return ['deposit', 'savings', 'investment', 'pension', 'realestate', 'car', 'loan', 'misc'];
                }
            });
            useEffect(() => {
                localStorage.setItem('assetDashboardAssetSectorOrder', JSON.stringify(assetSectorOrder));
            }, [assetSectorOrder]);

            // [추가] 입력 필드 참조를 위한 ref
            const assetInputRefs = useRef({});
            
            // ===== 초기 데이터 로드 =====
            useEffect(() => {
                const loadInitialData = async () => {
                const serverData = await loadServerConfig();
                const baseData = publicDefaultData; // <-- 이렇게 수정
                try {
                const savedData = localStorage.getItem('assetDashboardDataV3');
                const savedScenarios = localStorage.getItem('assetDashboardScenarios');

                // [수정] 아래 if문 추가
                if (savedScenarios) {
                    setScenarios(JSON.parse(savedScenarios));
                }

                if (savedData) {
                            const parsedData = JSON.parse(savedData);
                            // 새로운 필드들 추가
                            const mergedData = {
                                ...baseData,
                                ...parsedData,
                                assets: { ...baseData.assets, ...parsedData.assets },
                                rebalancingAlerts: { ...baseData.rebalancingAlerts, ...parsedData.rebalancingAlerts },
                            };
                            // [수정] memo가 누락된 경우 baseData에서 가져오도록 수정
                            if (mergedData.memo === undefined) mergedData.memo = baseData.memo;

                            // 마이그레이션: 자산별 수수료/세금 필드 기본값(0)
                            Object.keys(parsedData.assets||{}).forEach(sector=>{
                                (parsedData.assets[sector]||[]).forEach(a=>{ if (a.feeRate === undefined) a.feeRate = 0; });
                            });
                            setAppData(parsedData);
                            setOriginalUserData(parsedData); // [추가]
                        } else {
                            setAppData(baseData);
                            setOriginalUserData(baseData); // [추가]
                        }
                        
                    } catch (error) {
                        console.error("데이터 로드 오류:", error);
                        setAppData(baseData);
                    }
                };
                
                loadInitialData();
            }, []);

            // ===== 데이터 자동 저장 =====
            useEffect(() => {
            if (appData && !isDemoMode) { // [수정] 데모 모드일 때는 저장하지 않음
                localStorage.setItem('assetDashboardDataV3', JSON.stringify(appData));
                setOriginalUserData(appData); // [추가]
            }
            }, [appData, isDemoMode]); // [수정] isDemoMode를 의존성 배열에 추가

            // useRef를 사용하여 첫 렌더링인지 추적하는 변수 추가
            const isInitialMount = useRef(true);

            useEffect(() => {
                // 첫 렌더링일 경우, 아무것도 하지 않고 스위치만 false로 변경
                if (isInitialMount.current) {
                    isInitialMount.current = false;
                } else {
                    // 첫 렌더링이 아닐 때만 localStorage에 저장
                    localStorage.setItem('assetDashboardScenarios', JSON.stringify(scenarios));
                }
            }, [scenarios]);

            // ===== 자산 히스토리 관리 =====
            const [assetHistory, setAssetHistory] = React.useState([]);
            
            // 히스토리 데이터 로드
            React.useEffect(() => {
                try {
                    const savedHistory = localStorage.getItem('assetDashboardHistory');
                    if (savedHistory) {
                        setAssetHistory(JSON.parse(savedHistory));
                    }
                } catch (error) {
                    console.error('히스토리 데이터 로드 오류:', error);
                }
            }, []);

            // 히스토리 데이터 저장
            React.useEffect(() => {
                if (assetHistory.length > 0) {
                    localStorage.setItem('assetDashboardHistory', JSON.stringify(assetHistory));
                }
            }, [assetHistory]);

            // 현재 자산 저장 함수
            const saveCurrentAsset = () => {
                try {
                    const now = new Date();
                    const currentDate = now.toISOString().split('T')[0]; // YYYY-MM-DD
                    const currentTime = now.toTimeString().split(' ')[0]; // HH:MM:SS
                    const netWorth = calculation?.grand || 0;
                    
                    setAssetHistory(prev => {
                        const newHistory = [...prev];
                        const existingIndex = newHistory.findIndex(item => item.date === currentDate);
                        
                        if (existingIndex >= 0) {
                            // 같은 날짜가 있으면 시간 정보와 함께 업데이트 (마지막 시간대만 유지)
                            newHistory[existingIndex] = { 
                                date: currentDate, 
                                time: currentTime,
                                netWorth,
                                timestamp: now.getTime()
                            };
                        } else {
                            // 새로운 날짜면 추가
                            newHistory.push({ 
                                date: currentDate, 
                                time: currentTime,
                                netWorth,
                                timestamp: now.getTime()
                            });
                        }
                        
                        // 타임스탬프순으로 정렬 (최신이 마지막)
                        return newHistory.sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));
                    });
                    
                    alert(`현재 순자산 ${formatNumber(netWorth)}만원이 히스토리에 저장되었습니다.\n(${currentDate} ${currentTime})`);
                } catch (error) {
                    console.error('자산 저장 오류:', error);
                    alert('자산 저장 중 오류가 발생했습니다.');
                }
            };

            // ===== 데이터 이삿짐싸기 기능 =====
            const handleExport = async (selection) => {
                try {
                    const exportData = {};
                    if (selection.appData) exportData.appData = appData;
                    if (selection.scenarios) exportData.scenarios = scenarios;
                    if (selection.assetHistory) exportData.assetHistory = assetHistory;

                    exportData.exportDate = new Date().toISOString();
                    exportData.version = '1.0';

                    const jsonString = JSON.stringify(exportData);
                    // [개선] 압축 레벨 9 적용 및 안정적인 변환
                    const compressedDataArray = pako.deflate(jsonString, { level: 9 });

                    // [핵심 수정] Uint8Array를 Base64로 안전하게 변환 (스택 오버플로우 방지)
                    const blob = new Blob([compressedDataArray], { type: 'application/octet-stream' });
                    const dataUrl = await new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(blob);
                    });
                    const compressed = dataUrl.split(',')[1];

                    // 클립보드에 복사
                    navigator.clipboard.writeText(compressed).then(() => {
                        alert('자산 데이터가 클립보드에 복사되었습니다!\n다른 기기에서 "자산 불러오기" 버튼을 눌러 붙여넣기하세요.');
                    }).catch(() => {
                        alert('클립보드 복사에 실패했습니다. 수동으로 복사해주세요.');
                    });
                } catch (error) {
                    console.error('데이터 내보내기 오류:', error);
                    alert('데이터 내보내기 중 오류가 발생했습니다.');
                }
            };

            const handleImport = async (selection) => {
                const compressedData = prompt('다른 기기에서 복사한 암호문을 붙여넣으세요:');
                if (!compressedData) return;

                try {
                    // [개선] Base64를 Uint8Array로 안전하게 변환 (스택 오버플로우 방지)
                    const response = await fetch(`data:application/octet-stream;base64,${compressedData}`);
                    const blob = await response.blob();
                    const compressedDataArray = new Uint8Array(await blob.arrayBuffer());

                    const jsonString = pako.inflate(compressedDataArray, { to: 'string' });
                    const importData = JSON.parse(jsonString);

                    if (!importData.version) {
                        throw new Error('잘못된 데이터 형식입니다.');
                    }

                    if (confirm('현재 데이터를 모두 덮어쓰고 불러오시겠습니까?')) {
                        if (selection.appData && importData.appData) setAppData(importData.appData);
                        if (selection.scenarios && importData.scenarios) setScenarios(importData.scenarios);
                        if (selection.assetHistory && importData.assetHistory) setAssetHistory(importData.assetHistory);
                        alert('자산 데이터가 성공적으로 불러와졌습니다!');
                    }
                } catch (error) {
                    console.error('데이터 가져오기 오류:', error);
                    alert('데이터 가져오기 중 오류가 발생했습니다.\n암호문을 다시 확인해주세요.');
                }
            };

            // ===== 기본값 설정 (appData가 없을 때도 안전하게) =====
            const {
                projectionMonths = 12, monthlySalary = 280, assets = {}, monthlyExpenses = [], 
                incomeEvents = [], expenseEvents = [], targetAmount = 10000, 
                goalMode = 'period', displayMode = 'amount',
                rebalancingAlerts = {}, baseMonth = new Date().toISOString().slice(0,7),
                rebalancingTargets = {},
                memo = '' // [추가]
            } = appData || {};
            const applyTax = false;
            // ===== Setter 함수들 =====
            const setProjectionMonths = (value) => setAppData(prev => ({ ...prev, projectionMonths: value }));
            const setMonthlySalary = (value) => setAppData(prev => ({ ...prev, monthlySalary: value }));
            const setAssets = (value) => setAppData(prev => ({ ...prev, assets: typeof value === 'function' ? value(prev.assets) : value }));
            const setMonthlyExpenses = (value) => setAppData(prev => ({ 
                ...prev, 
                monthlyExpenses: typeof value === 'function' ? value(Array.isArray(prev.monthlyExpenses) ? prev.monthlyExpenses : []) : value 
            }));
            const setIncomeEvents = (value) => setAppData(prev => ({ 
                ...prev, 
                incomeEvents: typeof value === 'function' ? value(Array.isArray(prev.incomeEvents) ? prev.incomeEvents : []) : value 
            }));
            const setExpenseEvents = (value) => setAppData(prev => ({ 
                ...prev, 
                expenseEvents: typeof value === 'function' ? value(Array.isArray(prev.expenseEvents) ? prev.expenseEvents : []) : value 
            }));
            
            const setTargetAmount = (value) => setAppData(prev => ({ ...prev, targetAmount: value }));
            const setGoalMode = (value) => setAppData(prev => ({ ...prev, goalMode: value }));
            const setDisplayMode = (value) => setAppData(prev => ({ ...prev, displayMode: value })); 
            const setRebalancingAlerts = (value) => setAppData(prev => ({ ...prev, rebalancingAlerts: typeof value === 'function' ? value(prev.rebalancingAlerts) : value }));
            const setBaseMonth = (value) => setAppData(prev => ({ ...prev, baseMonth: value }));
            const setRebalancingTargets = (value) => setAppData(prev => ({ ...prev, rebalancingTargets: typeof value === 'function' ? value(prev.rebalancingTargets) : value }));
            const setMemo = (value) => setAppData(prev => ({ ...prev, memo: value })); // [추가]



            const saveAsDefault = () => {
                if (confirm('현재 설정을 기본값으로 저장하시겠습니까?')) {
                    localStorage.setItem('assetDashboardCustomDefault', JSON.stringify(appData));
                    alert('현재 설정이 기본값으로 저장되었습니다.');
                }
            };

            const loadCustomDefault = () => {
                try {
                    const customDefault = localStorage.getItem('assetDashboardCustomDefault');
                    if (customDefault) {
                        if (confirm('저장된 기본값으로 초기화하시겠습니까?')) {
                            const parsed = JSON.parse(customDefault);
                            // 스키마 보정: 누락 필드 채움
                            const fallback = publicDefaultData;
                            if (!parsed.assets) parsed.assets = fallback.assets;
                            if (!parsed.monthlySalary) parsed.monthlySalary = fallback.monthlySalary;
                            if (!parsed.projectionMonths) parsed.projectionMonths = fallback.projectionMonths;
                            setAppData(parsed);
                            setOriginalUserData(parsed); // [추가]
                            setIsDemoMode(false); // [추가]
                            localStorage.setItem('assetDashboardUseDevDefaults','false');
                            alert('저장된 기본값으로 초기화되었습니다.');
                        }
                    } else {
                        if (confirm('저장된 기본값이 없습니다.\n사이트 기본값으로 초기화하시겠습니까?')) {
                            setAppData(publicDefaultData);
                            setOriginalUserData(publicDefaultData); // [추가]
                            setIsDemoMode(false); // [추가]
                            alert('저장된 기본값이 없어 사이트 기본값으로 불러왔습니다.');
                        }
                    }
                } catch (error) {
                    console.error('기본값 로드 오류:', error);
                    alert('기본값 로드 중 오류가 발생했습니다.');
                }
            };

            const cycleDisplayMode = () => {
                // 현재: 사용자 모드 -> 다음: 프라이빗 모드
                if (!isDemoMode && appData?.displayMode === 'amount') {
                    setAppData(prev => ({ ...prev, displayMode: 'percent' }));
                    alert('프라이빗 모드로 전환합니다. 금액이 숨겨집니다.');
                } 
                // 현재: 프라이빗 모드 -> 다음: 데모 모드
                else if (!isDemoMode && appData?.displayMode === 'percent') {
                    setAppData(publicDefaultData);
                    setIsDemoMode(true);
                    alert('데모 모드로 전환합니다. 이 모드에서 변경한 내용은 저장되지 않습니다.');
                } 
                // 현재: 데모 모드 -> 다음: 사용자 모드
                else {
                    // displayMode를 'amount'로 되돌려야 합니다.
                    setAppData({...originalUserData, displayMode: 'amount'});
                    setIsDemoMode(false);
                    alert('사용자 데이터로 전환합니다.');
                }
            };

            // 제목에 표시될 텍스트
            const titleText = isDemoMode 
                ? <span className="text-sm text-red-500">(데모 모드)</span>
                : appData?.displayMode === 'percent' 
                    ? <span className="text-sm text-blue-500">(프라이빗 모드)</span> : null;

            // ===== 개선된 PDF 저장 함수 =====
            const saveToPDF = async () => {
                try {
                    // 로딩 알림 표시
                    const loadingAlert = document.createElement('div');
                    loadingAlert.className = 'fixed top-4 right-4 bg-blue-500 text-white px-4 py-2 rounded shadow-lg z-50';
                    loadingAlert.textContent = 'PDF 생성 중...';
                    document.body.appendChild(loadingAlert);

                    // 요소 확인
                    const element = document.getElementById('dashboard-content');
                    if (!element) {
                        throw new Error('대시보드 콘텐츠를 찾을 수 없습니다.');
                    }

                    // html2canvas 옵션 개선
                    const canvas = await html2canvas(element, {
                        scale: 1.5,
                        useCORS: true,
                        allowTaint: false,
                        backgroundColor: '#f9fafb',
                        logging: false,
                        width: element.scrollWidth,
                        height: element.scrollHeight,
                        scrollX: 0,
                        scrollY: 0
                    });
                    
                    const imgData = canvas.toDataURL('image/png', 0.8);
                    
                    // jsPDF 인스턴스 생성 확인 (UMD 네임스페이스 호환)
                    const JSPDF_NS = window.jspdf || window.jsPDF || window.jsPDFModule;
                    if (!JSPDF_NS || !JSPDF_NS.jsPDF) {
                        throw new Error('PDF 라이브러리를 로드할 수 없습니다.');
                    }
                    const pdf = new JSPDF_NS.jsPDF('p', 'mm', 'a4');
                    const imgWidth = 210;
                    const pageHeight = 295;
                    const imgHeight = (canvas.height * imgWidth) / canvas.width;
                    let heightLeft = imgHeight;
                    let position = 0;

                    // 첫 페이지
                    pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
                    heightLeft -= pageHeight;

                    // 추가 페이지
                    while (heightLeft >= 0) {
                        position = heightLeft - imgHeight;
                        pdf.addPage();
                        pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
                        heightLeft -= pageHeight;
                    }

                    // 파일명 생성
                    const fileName = `자산분석보고서_${new Date().toISOString().split('T')[0]}.pdf`;
                    pdf.save(fileName);
                    
                    // 성공 알림
                    loadingAlert.textContent = 'PDF 저장 완료!';
                    loadingAlert.className = 'fixed top-4 right-4 bg-green-500 text-white px-4 py-2 rounded shadow-lg z-50';
                    
                    setTimeout(() => {
                        if (document.body.contains(loadingAlert)) {
                            document.body.removeChild(loadingAlert);
                        }
                    }, 2000);

                } catch (error) {
                    console.error('PDF 저장 오류:', error);
                    
                    // 오류 알림
                    const errorAlert = document.createElement('div');
                    errorAlert.className = 'fixed top-4 right-4 bg-red-500 text-white px-4 py-2 rounded shadow-lg z-50';
                    errorAlert.textContent = `PDF 저장 실패: ${error.message}`;
                    document.body.appendChild(errorAlert);
                    
                    setTimeout(() => {
                        if (document.body.contains(errorAlert)) {
                            document.body.removeChild(errorAlert);
                        }
                    }, 5000);
                    // 혹시 남아있는 로딩 알림 제거
                    document.querySelectorAll('.fixed.top-4.right-4').forEach(el => {
                        if (el.textContent.includes('PDF')) {
                            el.parentNode && el.parentNode.removeChild(el);
                        }
                    });
                }
            };

            // ===== 시나리오 관리 함수들 =====
            const saveScenario = () => {
                const name = prompt('시나리오 이름을 입력하세요:');
                if (name && name.trim()) {
                    const newScenario = {
                        id: Date.now(),
                        name: name.trim(),
                        data: { ...appData },
                        createdAt: new Date().toISOString()
                    };
                    setScenarios(prev => [...prev, newScenario]);
                    alert('시나리오가 저장되었습니다.');
                }
            };

            const loadScenario = (scenario) => {
                if (confirm(`"${scenario.name}" 시나리오를 불러오시겠습니까?`)) {
                    setAppData(scenario.data);
                }
            };

            const deleteScenario = (id) => {
                if (confirm('시나리오를 삭제하시겠습니까?')) {
                    setScenarios(prev => prev.filter(s => s.id !== id));
                }
            };

            // ===== 예산 계산 =====
            const totalMonthlyExpense = useMemo(() => {
                if (!monthlyExpenses || !Array.isArray(monthlyExpenses)) return 0;
                return monthlyExpenses.reduce((sum, e) => sum + Number(e.amount || 0), 0);
            }, [monthlyExpenses]);
            
            const totalSectorMonthlyContrib = useMemo(() => {
                if (!assets || typeof assets !== 'object') return 0;
                let sum = 0;
                Object.entries(assets).forEach(([sector, arr]) => {
                    if (Array.isArray(arr)) {
                        arr.forEach(asset => { sum += Number(asset.monthlyContrib || 0); });
                    }
                });
                return sum;
            }, [assets]);
            
            const maxSectorMonthlyContrib = useMemo(() => Math.max(0, monthlySalary - totalMonthlyExpense), [monthlySalary, totalMonthlyExpense]);
            const autoDepositAmount = Math.max(0, maxSectorMonthlyContrib - totalSectorMonthlyContrib);

            // ===== 개선된 목표 달성 계산 =====
            const calculateGoalSeek = () => {
                if (!targetAmount || targetAmount <= 0) {
                    alert('유효한 목표 금액을 입력해주세요.');
                    return;
                }

                let months = 0;

                // [수정] 메인 계산 로직을 사용하여 목표 달성 시뮬레이션
                while (months < 600) { // 최대 50년(600개월)까지만 계산
                    months++;
                    const projections = calculateMonthlyProjection(appData, months);

                    // 계산 중 오류 발생 시 중단
                    if (projections.error) {
                        setGoalSeekResult(`계산 중 오류 발생: ${projections.message}`);
                        // 오류가 발생한 입력란으로 포커스 이동
                        if (projections.refId) {
                            const targetElement = assetInputRefs.current[projections.refId];
                            if (targetElement) {
                                targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                setTimeout(() => targetElement.focus(), 500);
                            }
                        }
                        return;
                    }

                    const finalProjection = projections[projections.length - 1];
                    if (finalProjection.total >= targetAmount) {
                        setGoalSeekResult(`목표 달성까지 약 ${months}개월 소요됩니다.`);
                        setProjectionMonths(months);
                        return;
                    }
                }
                
                // 매월 시뮬레이션
                setGoalSeekResult('현재 조건으로는 50년 내 목표 달성이 어렵습니다.');
            };

            // [추가] 레이아웃 이동 함수
            const movePanel = (id, direction) => {
                const index = layoutOrder.indexOf(id);
                if (index === -1) return;
                const newIndex = index + direction;
                if (newIndex < 0 || newIndex >= layoutOrder.length) return;
                const newOrder = [...layoutOrder];
                [newOrder[index], newOrder[newIndex]] = [newOrder[newIndex], newOrder[index]]; // Swap
                setLayoutOrder(newOrder);
            };

            // [추가] 패널 접힘/펼침 토글 함수
            const togglePanelCollapse = (panelId) => {
                setPanelCollapseState(prev => ({
                    ...prev,
                    [panelId]: !prev[panelId]
                }));
            };
            // ===== 메인 계산 로직 =====
            // [추가] 자산 섹터 이동 함수
            const moveAssetSector = (sectorKey, direction) => {
                const index = assetSectorOrder.indexOf(sectorKey);
                if (index === -1) return;
                const newIndex = index + direction;
                if (newIndex < 0 || newIndex >= assetSectorOrder.length) return;
                const newOrder = [...assetSectorOrder];
                [newOrder[index], newOrder[newIndex]] = [newOrder[newIndex], newOrder[index]]; // Swap
                setAssetSectorOrder(newOrder);
            };

            const calculateMonthlyProjection = (initialData, monthsToProject) => {
                const data = JSON.parse(JSON.stringify(initialData)); // Deep copy
                const monthlyProjections = [];

                const {
                    projectionMonths: initialProjectionMonths = 12, monthlySalary = 280, assets = {}, monthlyExpenses = [], 
                    incomeEvents = [], expenseEvents = [], targetAmount = 10000, 
                    goalMode = 'period', displayMode = 'amount', 
                    rebalancingAlerts = {}, baseMonth = new Date().toISOString().slice(0,7),
                    rebalancingMode = 'simple', simpleThresholds = { warning: 5, danger: 10 }, rebalancingTargets = {}
                } = data;

                let currentAssets = {};
                Object.keys(assets).forEach(sector => {
                    if (Array.isArray(assets[sector])) {
                        currentAssets[sector] = assets[sector].map(asset => ({ ...asset }));
                    } else {
                        currentAssets[sector] = [];
                    }
                });

                const allAccountsFlat = Object.values(currentAssets).flat();
                const totalMonthlyExpense = monthlyExpenses.reduce((sum, e) => sum + (e.amount || 0), 0);
                const monthlyContribSum = Object.values(assets).flat().reduce((s,a)=> s + (a.monthlyContrib||0),0);

                // [수정] 월 가용 현금 계산
                const monthlyAvailableCash = monthlySalary - totalMonthlyExpense;
                
                const calculateTotal = (assetData) => {
                    let sum = 0;
                    Object.keys(assetData).forEach(sector => {
                        const sectorSum = (assetData[sector]||[]).reduce((s,a)=> s + (a.amount||0), 0);
                        sum += (sector === 'loan') ? -sectorSum : sectorSum;
                    });
                    return sum;
                };

                for (let month = 0; month <= monthsToProject; month++) {
                    if (month > 0) { // Skip initial state for calculations, only record it
                        // 복리 수익률 적용 (자산별 수수료/세금 반영)
                        Object.keys(currentAssets).forEach(sector => {
                            if (sector === 'loan') return; 
                            currentAssets[sector].forEach(asset => {
                                const feeRate = (asset.feeRate || 0) / 100;
                                let effectiveRate = (asset.rate / 100) * (1 - feeRate);
                                const monthlyRate = 1 + (effectiveRate / 12);
                                asset.amount *= monthlyRate;
                            });
                        });

                        // 대출 이자 계산 (납입 전)
                        (currentAssets.loan || []).forEach(loan => {
                            if (loan.amount > 0 && loan.rate > 0) {
                                const monthlyInterest = loan.amount * (loan.rate / 100) / 12;
                                loan.amount += monthlyInterest; 
                            }
                        });
                        
                        // 만기일시 상환 처리
                        (currentAssets.loan || []).forEach(loan => {
                            if (loan.repaymentMethod === '만기일시' && month === (loan.maturityMonth || 0)) {
                                const repaymentAmount = loan.amount;
                                loan.amount = 0; // 원금 전액 상환
                            }
                        });

                        // 이벤트 적용
                        (incomeEvents || []).forEach(event => {
                            if (month >= event.startMonth && month <= event.endMonth) {
                                if (currentAssets[event.targetSector] && currentAssets[event.targetSector][event.targetAsset]) {
                                    currentAssets[event.targetSector][event.targetAsset].amount += event.amount;
                                }
                            }
                        });

                        (expenseEvents || []).forEach(event => {
                            if (month >= event.startMonth && month <= event.endMonth) {
                                const arr = currentAssets[event.targetSector];
                                if (arr && arr[event.targetAsset]) {
                                    arr[event.targetAsset].amount = Math.max(0, arr[event.targetAsset].amount - event.amount);
                                }
                            }
                        });

                        // [수정] 새로운 현금 흐름 로직
                        let cashInHand = monthlyAvailableCash;
                        const cashFlowAccount = allAccountsFlat.find(d => d.name === mainCashFlowAccount);

                        // 1. 월납입 처리
                        Object.keys(currentAssets).forEach(sector => {
                            currentAssets[sector].forEach(asset => {
                                if (asset.monthlyContrib > 0) {
                                    const paymentAmount = asset.monthlyContrib;
                                    const actualPayment = Math.min(paymentAmount, cashInHand);
                                    
                                    if (sector === 'loan') {
                                        asset.amount = Math.max(0, asset.amount - actualPayment);
                                    } else {
                                        asset.amount += actualPayment;
                                    }
                                    
                                    cashInHand -= actualPayment;

                                    if (paymentAmount > actualPayment) {
                                        // 월 가용 현금이 부족하여 월납입이 일부만 실행됨
                                        return { 
                                            error: true, 
                                            message: `월 가용 현금이 부족하여 [${asset.name}]의 월납입액 ${paymentAmount}만원 중 ${actualPayment}만원만 납입됩니다. 월급 또는 지출 계획을 확인해주세요.`,
                                            refId: null // 특정 필드를 가리키기 어려움
                                        };
                                    }
                                }
                            });
                        });

                        // 2. 남은 현금(잔여액)을 주 현금흐름 계좌에 입금
                        if (cashInHand > 0 && cashFlowAccount) {
                            cashFlowAccount.amount += cashInHand;
                        }

                        // 3. 월수입 외 납입 처리 (이 로직은 특정 계좌에서 출금되므로 순서상 마지막에 배치)
                        Object.keys(currentAssets).forEach(sector => {
                            currentAssets[sector].forEach(asset => {
                                // [추가] 대출 상환 로직
                                if (sector === 'loan' && asset.monthlyContrib > 0 && asset.repaymentAccount) {
                                    let fromAccount = allAccountsFlat.find(d => d.name === asset.repaymentAccount);
                                    if (fromAccount) {
                                        const actualDeduction = Math.min(asset.monthlyContrib, fromAccount.amount);
                                        fromAccount.amount -= actualDeduction;
                                        asset.amount = Math.max(0, asset.amount - actualDeduction);
                                    }
                                }

                                // 월수입 외 추가 납입
                                if (asset.extraContrib > 0 && asset.extraFrom) {
                                    let fromAccount = allAccountsFlat.find(d => d.name === asset.extraFrom);
                                    if (fromAccount === asset) {
                                        fromAccount = {...fromAccount};
                                    }
                                    let actualDeduction = 0; // [수정] 변수명 명확화
                                    if (fromAccount) {
                                        actualDeduction = Math.min(asset.extraContrib, fromAccount.amount); 
                                        fromAccount.amount -= actualDeduction;
                                        if (asset.extraContrib > actualDeduction) {
                                            const fromSectorKey = Object.keys(currentAssets).find(key => currentAssets[key].some(a => a.name === fromAccount.name));
                                            const fromAssetIndex = currentAssets[fromSectorKey]?.findIndex(a => a.name === fromAccount.name);
                                            return { 
                                                error: true, 
                                                message: `${month}개월차에 [${fromAccount.name}] 계좌의 잔액이 부족하여 요청하신 ${asset.extraContrib}만원 중 ${actualDeduction}만원만 ${asset.name}로 납입됩니다.`,
                                                refId: `${fromSectorKey}-${fromAssetIndex}-amount`
                                            };
                                        }
                                    }
                                    if (sector === 'loan') {
                                        asset.amount = Math.max(0, asset.amount - actualDeduction);
                                    } else {
                                        asset.amount += actualDeduction;
                                    }
                                }
                            });
                        });
                    }
                    
                    // Record current state
                    const currentTotal = calculateTotal(currentAssets);
                    const currentGross = Object.keys(currentAssets).filter(k=>k!=='loan').reduce((s,k)=> s + (currentAssets[k]||[]).reduce((sum,a)=>sum+(a.amount||0),0),0);
                    const sectorTotals = {};
                    Object.keys(currentAssets).forEach(sector => {
                        if (sector === 'loan') return;
                        const sectorSum = (currentAssets[sector]||[]).reduce((sum, asset) => sum + (asset.amount || 0), 0);
                        sectorTotals[sector] = { amount: sectorSum, percentage: currentGross > 0 ? (sectorSum / currentGross * 100) : 0 };
                    });

                    const itemTotals = {};
                    Object.keys(currentAssets).forEach(sector => {
                        itemTotals[sector] = (currentAssets[sector]||[]).map(asset => ({
                            name: asset.name,
                            amount: asset.amount,
                            percentage: (sectorTotals[sector]?.amount > 0) ? (asset.amount / sectorTotals[sector].amount * 100) : 0
                        }));
                    });

                    monthlyProjections.push({
                        month: month,
                        total: currentTotal,
                        gross: currentGross,
                        sectorTotals: sectorTotals,
                        itemTotals: itemTotals,
                        assets: JSON.parse(JSON.stringify(currentAssets)) // Deep copy for each month
                    });
                }
                return monthlyProjections;
            };

            const calculation = useMemo(() => {
                if (!appData || !assets || typeof assets !== 'object') {
                    return {
                        initial: {},
                        projected: {},
                        currentTotal: 0,
                        projectedTotal: 0,
                        growth: 0,
                        grand: 0,
                        monthlyProjections: []
                    };
                }
                
                const months = projectionMonths;
                const monthlyProjections = calculateMonthlyProjection(appData, months);

                // [추가] 계산 오류 처리
                if (monthlyProjections.error) {
                    alert(monthlyProjections.message);
                    if (monthlyProjections.refId && assetInputRefs.current) {
                        const targetElement = assetInputRefs.current[monthlyProjections.refId];
                        if (targetElement) {
                            targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            // 하이라이트 효과 추가
                            targetElement.classList.add('bg-red-200', 'transition-all', 'duration-1000');
                            setTimeout(() => {
                                targetElement.focus();
                                // 1초 후 하이라이트 제거
                                setTimeout(() => targetElement.classList.remove('bg-red-200'), 1000);
                            }, 500);
                        }
                    }
                    return { error: true }; // 오류 상태 반환
                }

                const finalProjection = monthlyProjections[months];

                const calculateTotal = (assetData) => {
                    let sum = 0;
                    Object.keys(assetData).forEach(sector => {
                        const sectorSum = (assetData[sector]||[]).reduce((s,a)=> s + (a.amount||0), 0);
                        sum += (sector === 'loan') ? -sectorSum : sectorSum;
                    });
                    return sum;
                };

                const currentTotal = calculateTotal(appData.assets);
                const projectedTotal = finalProjection ? finalProjection.total : currentTotal;

                return {
                    initial: appData.assets,
                    projected: finalProjection ? finalProjection.assets : appData.assets,
                    currentTotal,
                    projectedTotal,
                    growth: projectedTotal - currentTotal,
                    grand: currentTotal,
                    monthlyProjections: monthlyProjections
                };
            }, [appData, projectionMonths, monthlySalary, monthlyExpenses, incomeEvents, expenseEvents, mainCashFlowAccount, isDemoMode, rebalancingTargets]);

           
            // ===== 유틸리티 함수들 =====
            const formatNumber = (num) => {
                if (displayMode === 'percent') return '***'; // [추가] 금액 숨김 모드
                return Math.round(num).toLocaleString();
            };
            const formatPercent = (num) => num.toFixed(1);
            
            const calculateGrossTotal = (assetData) => {
                if (!assetData || typeof assetData !== 'object') return 0;
                let sum = 0;
                Object.keys(assetData).forEach(sector => {
                    if (sector === 'loan') return; // 부채 제외
                    const arr = assetData[sector] || [];
                    sum += arr.reduce((s,a)=> s + (a.amount||0), 0);
                });
                return sum;
            };

            const getSectorTotals = (assetData, total) => {
                const totals = {};
                if (!assetData || typeof assetData !== 'object') return totals;
                
                Object.keys(assetData).forEach(sector => {
                    if (sector === 'loan') return; // 대출은 비율/차트 계산에서 제외
                    if (Array.isArray(assetData[sector])) {
                        const sectorTotal = assetData[sector].reduce((sum, asset) => sum + (asset.amount || 0), 0);
                        totals[sector] = { amount: sectorTotal, percentage: total > 0 ? (sectorTotal / total * 100) : 0 };
                    }
                });
                return totals;
            };

            const currentGrossTotal = calculateGrossTotal(calculation.initial);
            const projectedGrossTotal = calculateGrossTotal(calculation.projected);
            const currentSectorTotals = getSectorTotals(calculation.initial, currentGrossTotal);
            const projectedSectorTotals = getSectorTotals(calculation.projected, projectedGrossTotal);

            // ===== 리밸런싱 경고 함수 (목표 비중 기준 편차) =====
            const getRebalanceStatus = (sectorKey, percentage) => {
                const target = rebalancingTargets[sectorKey] ?? (100 / Object.keys(sectorInfo).length);
                const deviation = Math.abs(percentage - target);
                const thresholds = rebalancingAlerts[sectorKey] || { warning: 5, danger: 10 };
                if (deviation >= thresholds.danger) return 'bg-red-100 text-red-800';
                if (deviation >= thresholds.warning) return 'bg-yellow-100 text-yellow-800';
                return '';
            };

            // ===== 자동입금 계산식 표시 함수 =====
            const getAutoDepositBreakdown = () => {
                const breakdown = [];
                Object.keys(assets).forEach(sectorKey => {
                    if (Array.isArray(assets[sectorKey])) {
                        assets[sectorKey].forEach(asset => {
                            if (asset.monthlyContrib > 0) {
                                breakdown.push({
                                    sector: sectorKey,
                                    name: asset.name,
                                    amount: asset.monthlyContrib
                                });
                            }
                        });
                    }
                });
                return breakdown;
            };

            const autoDepositBreakdown = getAutoDepositBreakdown();

            // ===== 차트 설정 =====
            useEffect(() => {
    // [개선] 차트 패널이 접혀있으면, 굳이 차트를 다시 그리지 않습니다.
    // 이렇게 하면 다른 패널을 조작할 때 불필요한 리렌더링 애니메이션이 보이지 않습니다.
    if (panelCollapseState['charts']) return;

    if (!appData || !currentPieRef.current || !projectedPieRef.current || !comparisonBarRef.current) return;
    const sectorLabels = {
        deposit: '입출금통장',
        savings: '저축',
        investment: '투자',
        pension: '연금',
        realestate: '부동산',
        car: '자동차',
        loan: '대출',
        misc: '기타'
    };

    // 기존 차트 인스턴스가 있다면 파괴합니다.
    [currentPieRef, projectedPieRef, comparisonBarRef].forEach(ref => {
        if (ref.current && ref.current._chart) {
            ref.current._chart.destroy();
        }
    });

    // 차트 데이터 준비
    const filteredKeys = Object.keys(currentSectorTotals).filter(k => k !== 'loan');
    const currentLabels = filteredKeys.map(key => sectorLabels[key]);
    const currentData = filteredKeys.map(key => currentSectorTotals[key]?.amount || 0);
    const projectedKeys = Object.keys(projectedSectorTotals).filter(k => k !== 'loan');
    const projectedLabels = projectedKeys.map(key => sectorLabels[key]);
    const projectedData = projectedKeys.map(key => projectedSectorTotals[key].amount);

    const forecastDateText = (() => {
        const [y,m] = (baseMonth || new Date().toISOString().slice(0,7)).split('-').map(Number);
        const date = new Date(y, m - 1 + projectionMonths);
        return `${String(date.getFullYear()).slice(2)}년 ${String(date.getMonth()+1).padStart(2,'0')}월`;
    })();

    const createGradient = (ctx, colors) => {
        const gradient = ctx.createLinearGradient(0, 0, 0, 400);
        gradient.addColorStop(0, colors.start);
        gradient.addColorStop(1, colors.end);
        return gradient;
    };

    // 현재 포트폴리오 차트
    currentPieRef.current._chart = new Chart(currentPieRef.current, {
        type: 'doughnut',
        data: { 
            labels: currentLabels, 
            datasets: [{ 
                data: currentData, 
                backgroundColor: filteredKeys.map(key => {
                    const colors = tailwind.config.theme.extend.colors[key];
                    return createGradient(currentPieRef.current.getContext('2d'), colors);
                }),
                borderWidth: 3,
                borderColor: '#ffffff',
                hoverBorderWidth: 5,
                hoverBorderColor: '#ffffff',
                hoverOffset: 40
            }] 
        },
        options: {
            responsive: true,
            animation: {
                animateScale: true,
                animateRotate: true,
                duration: 1500,
                easing: 'easeInOutQuart'
            },
            plugins: { 
                legend: { position: 'bottom' },
                title: { display: true, text: '현재 포트폴리오' },
                datalabels: {
                    anchor: 'end',
                    align: 'start',
                    offset: 20,
                    color: '#111827',
                    font: function(context) {
                        return {
                            weight: 'bold',
                            size: context.active ? 16 : 11
                        };
                    },
                    borderRadius: 4,
                    padding: 6,
                    formatter: (value, context) => {
                        const total = context.chart.data.datasets[0].data.reduce((a, b) => a + b, 0) || 1;
                        const percentage = (value / total) * 100;
                        return (percentage > 5 || context.active) ? `${percentage.toFixed(1)}%` : '';
                    }
                },
                tooltip: {
                    backgroundColor: 'rgba(0, 0, 0, 0.85)',
                    titleFont: { size: 14, weight: 'bold' },
                    bodyFont: { size: 13 },
                    padding: 12,
                    cornerRadius: 8,
                    displayColors: true,
                    callbacks: {
                        label: function(context) {
                            const label = context.label || '';
                            const value = Math.round(context.parsed).toLocaleString();
                            const total = context.dataset.data.reduce((a, b) => a + b, 0);
                            const percentage = ((context.parsed / total) * 100).toFixed(1);
                            return ` ${label}: ${value}만원 (${percentage}%)`;
                        }
                    }
                }
            }
        },
        plugins: [ChartDataLabels]
    });

    // 예상 포트폴리오 차트
    projectedPieRef.current._chart = new Chart(projectedPieRef.current, {
        type: 'doughnut',
        data: { 
            labels: projectedLabels, 
            datasets: [{ 
                data: projectedData, 
                backgroundColor: projectedKeys.map(key => {
                    const colors = tailwind.config.theme.extend.colors[key];
                    return createGradient(projectedPieRef.current.getContext('2d'), colors);
                }),
                borderWidth: 3,
                borderColor: '#ffffff',
                hoverBorderWidth: 5,
                hoverBorderColor: '#ffffff',
                hoverOffset: 40
            }] 
        },
        options: {
            responsive: true,
            animation: {
                animateScale: true,
                animateRotate: true,
                duration: 1500,
                easing: 'easeInOutQuart',
                delay: 200
            },
            plugins: {
                legend: { position: 'bottom' },
                title: { display: true, text: `${projectionMonths}개월 후 예상 ${forecastDateText ? `(${forecastDateText})` : ''}` },
                datalabels: {
                    anchor: 'end', 
                    align: 'start',
                    offset: 20,
                    color: '#111827',
                    font: function(context) {
                        return {
                            weight: 'bold',
                            size: context.active ? 16 : 11
                        };
                    },
                    borderRadius: 4,
                    padding: 6,
                    formatter: (value, context) => {
                        const total = context.chart.data.datasets[0].data.reduce((a, b) => a + b, 0) || 1;
                        const percentage = (value / total) * 100;
                        return (percentage > 5 || context.active) ? `${percentage.toFixed(1)}%` : '';
                    }
                },
                tooltip: {
                    backgroundColor: 'rgba(0, 0, 0, 0.85)',
                    titleFont: { size: 14, weight: 'bold' },
                    bodyFont: { size: 13 },
                    padding: 12,
                    cornerRadius: 8,
                    displayColors: true,
                    callbacks: {
                        label: function(context) {
                            const label = context.label || '';
                            const value = Math.round(context.parsed).toLocaleString();
                            const total = context.dataset.data.reduce((a, b) => a + b, 0);
                            const percentage = ((context.parsed / total) * 100).toFixed(1);
                            return ` ${label}: ${value}만원 (${percentage}%)`;
                        }
                    }
                }
            }
        },
        plugins: [ChartDataLabels]
    });

    // 비교 차트
comparisonBarRef.current._chart = new Chart(comparisonBarRef.current, {
    type: 'bar',
    data: {
        labels: projectedLabels,
        datasets: [
            { 
                label: '현재', 
                data: currentData, 
                backgroundColor: 'rgba(156, 163, 175, 0.7)',
                borderColor: 'rgba(107, 114, 128, 1)',
                borderWidth: 2,
                borderRadius: 6,
                borderSkipped: false
            },
            { 
                label: '예상', 
                data: projectedData, 
                backgroundColor: (context) => {
                    const ctx = context.chart.ctx;
                    const gradient = ctx.createLinearGradient(0, 0, 0, 400);
                    gradient.addColorStop(0, 'rgba(96, 165, 250, 0.9)');
                    gradient.addColorStop(1, 'rgba(59, 130, 246, 0.8)');
                    return gradient;
                },
                borderColor: '#3b82f6',
                borderWidth: 2,
                borderRadius: 6,
                borderSkipped: false
            }
        ]
    },
    options: {
        responsive: true,
        scales: { x: { position: 'bottom' }, y: { beginAtZero: true } },
        plugins: {
            legend: { 
                position: 'top',
                align: 'end',
                labels: { usePointStyle: true, pointStyle: 'rectRounded' }
            },
            title: { 
                display: true, 
                text: '📊 현재 자산 vs 예상 자산',
                font: { size: 18, weight: 'bold' },
                padding: { top: 10, bottom: 20 }
            },
            tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.85)',
                titleFont: { size: 14, weight: 'bold' },
                bodyFont: { size: 13 },
                padding: 12,
                cornerRadius: 8,
                displayColors: true,
                callbacks: {
                    label: function(context) {
                        const value = Math.round(context.parsed.y).toLocaleString();
                        return ` ${context.dataset.label}: ${value}만원`;
                    }
                }
            },
            // 막대 차트에서는 데이터 라벨을 숨겨 깔끔하게 표시
            datalabels: { display: false }
        }
    },
    plugins: []
});
            }, [appData, calculation, projectionMonths, baseMonth, panelCollapseState['charts']]);



            // [분리] 히스토리 차트 전용 useEffect
            useEffect(() => {
                if (panelCollapseState['history']) return; // 히스토리 패널이 접혀있으면 실행 안함
                if (!historyChartRef.current || assetHistory.length === 0) return;

                if (historyChartRef.current._chart) {
                    historyChartRef.current._chart.destroy();
                }
                
                const historyLabels = assetHistory.map(item => {
                    const date = new Date(item.date);
                    const timeStr = item.time ? ` ${item.time.split(':').slice(0, 2).join(':')}` : '';
                    return `${date.getMonth() + 1}/${date.getDate()}${timeStr}`;
                });
                const historyData = assetHistory.map(item => item.netWorth);
                
                historyChartRef.current._chart = new Chart(historyChartRef.current, {
                    type: 'line',
                    data: {
                        labels: historyLabels,
                        datasets: [{
                            label: '순자산 (만원)',
                            data: historyData,
                            borderColor: 'rgb(79, 70, 229)',
                            backgroundColor: (context) => {
                                const ctx = context.chart.ctx;
                                const gradient = ctx.createLinearGradient(0, 0, 0, 200);
                                gradient.addColorStop(0, 'rgba(79, 70, 229, 0.3)');
                                gradient.addColorStop(1, 'rgba(79, 70, 229, 0)');
                                return gradient;
                            },
                            tension: 0.3,
                            fill: true,
                            pointBackgroundColor: 'rgb(79, 70, 229)',
                            pointHoverRadius: 6,
                            pointHoverBackgroundColor: 'rgb(255, 255, 255)',
                            pointHoverBorderWidth: 2,
                            pointHoverBorderColor: 'rgb(79, 70, 229)'
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: { position: 'bottom' },
                            title: { display: false },
                            tooltip: { mode: 'index', intersect: false }
                        },
                        scales: { y: { beginAtZero: true } }
                    }
                });
            }, [assetHistory, panelCollapseState['history']]);

            // ===== 로딩 상태 처리 =====
            if (!appData) {
                return <div className="flex items-center justify-center min-h-screen">로딩 중...</div>;
            }

            // ===== 자산 관리 함수들 =====
            const addAsset = (sector) => setAssets(prev => ({
                ...prev,
                [sector]: [...(prev[sector] || []), {
                    id: Date.now() + Math.random(), // [개선] 고유 ID 추가
                    name: '새 항목',
                    amount: 0,
                    rate: sector === 'loan' ? 3.0 : (sector === 'car' ? -2.0 : 10.0),
                    feeRate: 0,
                    monthlyContrib: 0, // 대출의 경우 '월 상환액'으로 사용
                    extraContrib: 0, // 대출의 경우 '추가 상환액'으로 사용
                    extraFrom: (Object.values(prev).flat().find(a => a.name === '생활비통장')?.name) || (Object.values(prev).flat()[0]?.name) || '', // '추가 상환' 출금 계좌
                    // [추가] 대출 전용 필드 기본값
                    repaymentMethod: '원리금균등', // 상환방식
                    repaymentAccount: (Object.values(prev).flat().find(a => a.name === '생활비통장')?.name) || (Object.values(prev).flat()[0]?.name) || '', // '월 상환액' 출금 계좌
                    maturityMonth: 12 // [추가] 만기 (개월)
                }]
            }));

            const updateAsset = (sector, index, field, value) => {
                // 👇 [개선] 숫자여야 하는 필드 목록을 만듭니다.
                const numberFields = ['amount', 'rate', 'feeRate', 'monthlyContrib', 'extraContrib', 'maturityMonth'];

                // 👇 [개선] 해당 필드만 숫자로 변환하고, 나머지는(계좌 이름 등) 문자열로 둡니다.
                let newValue = numberFields.includes(field) ? Number(value) : value;

                if (numberFields.includes(field) && isNaN(newValue)) {
                    newValue = 0; // 숫자가 아닌 값이 들어오면 0으로 처리
                }

                if ((field === 'monthlyContrib' || field === 'extraContrib') && newValue < 0) return;
                setAssets(prev => ({
                    ...prev,
                    [sector]: prev[sector].map((asset, i) => i === index ? { ...asset, [field]: newValue } : asset)
                }));
            };

            const removeAsset = (sector, index) => setAssets(prev => ({
                ...prev,
                [sector]: prev[sector].filter((_, i) => i !== index)
            }));

            // ===== 지출 관리 함수들 =====
            const addExpense = () => setMonthlyExpenses(prev => [...prev, { name: '새 지출', amount: 0 }]);
            const updateExpense = (index, field, value) => setMonthlyExpenses(prev => prev.map((expense, i) => 
                i === index ? { ...expense, [field]: field === 'name' ? value : Number(value) } : expense
            ));
            const removeExpense = (index) => setMonthlyExpenses(prev => prev.filter((_, i) => i !== index));

            // ===== 섹터 정보 (함수 정의 전에 위치) =====
            const sectorInfo = {
                deposit: { name: '입출금통장', color: 'deposit', icon: '🏦' },
                savings: { name: '저축', color: 'savings', icon: '💰' },
                investment: { name: '투자', color: 'investment', icon: '📈' },
                pension: { name: '연금', color: 'pension', icon: '🏛️' },
                realestate: { name: '부동산', color: 'realestate', icon: '🏠' },
                car: { name: '자동차', color: 'car', icon: '🚗' },
                loan: { name: '대출', color: 'loan', icon: '💳' },
                misc: { name: '기타', color: 'misc', icon: '📦' }
            };

            // ===== 이벤트 관리 함수들 =====
            const addIncomeEvent = () => {
                setIncomeEvents(prev => {
                    // [개선] prev가 배열이 아닐 경우를 대비하여 안전하게 처리
                    const currentEvents = Array.isArray(prev) ? prev : [];
                    return [...currentEvents, { 
                        name: '새 수입 이벤트', amount: 0, startMonth: 1, endMonth: 1, targetSector: 'deposit', targetAsset: 0 
                    }];
                });
            };
            
            const updateIncomeEvent = (index, field, value) => {
                try {
                    // incomeEvents가 배열인지 확인
                    if (!Array.isArray(incomeEvents)) {
                        console.warn('incomeEvents is not an array:', incomeEvents);
                        return;
                    }
                    
                    // 입력값 검증
                    if (index < 0 || index >= incomeEvents.length) {
                        console.warn('Invalid income event index:', index);
                        return;
                    }
                    
                    let newValue = value;
                    
                    // 숫자 필드 검증
                    if (field === 'amount' || field === 'startMonth' || field === 'endMonth' || field === 'targetAsset') {
                        const numValue = Number(value);
                        if (isNaN(numValue)) {
                            console.warn('Invalid number value:', value);
                            return;
                        }
                        newValue = Math.max(0, numValue); // 음수 방지
                    }
                    
                    // 섹터 필드 검증
                    if (field === 'targetSector' && !Object.keys(sectorInfo).includes(value)) {
                        console.warn('Invalid target sector:', value);
                        return;
                    }
                    
                    setIncomeEvents(prev => {
                        if (!Array.isArray(prev)) {
                            console.warn('Previous incomeEvents is not an array:', prev);
                            return prev;
                        }
                        return prev.map((event, i) => 
                            i === index ? { ...event, [field]: newValue } : event
                        );
                    });
                } catch (error) {
                    console.error('Error updating income event:', error);
                }
            };
            
            const removeIncomeEvent = (index) => {
                try {
                    // incomeEvents가 배열인지 확인
                    if (!Array.isArray(incomeEvents)) {
                        console.warn('incomeEvents is not an array:', incomeEvents);
                        return;
                    }
                    
                    // 인덱스 검증
                    if (index < 0 || index >= incomeEvents.length) {
                        console.warn('Invalid income event index for removal:', index);
                        return;
                    }
                    
                    setIncomeEvents(prev => {
                        if (!Array.isArray(prev)) {
                            console.warn('Previous incomeEvents is not an array:', prev);
                            return prev;
                        }
                        return prev.filter((_, i) => i !== index);
                    });
                } catch (error) {
                    console.error('Error removing income event:', error);
                }
            };

            const addExpenseEvent = () => setExpenseEvents(prev => {
                // [개선] prev가 배열이 아닐 경우를 대비하여 안전하게 처리
                const currentEvents = Array.isArray(prev) ? prev : [];
                return [...currentEvents, { 
                    name: '새 지출 이벤트', amount: 0, startMonth: 1, endMonth: 1, targetSector: 'deposit', targetAsset: 0 
                }];
            });
            const updateExpenseEvent = (index, field, value) => {
                let newValue = value;
                const numberFields = ['amount', 'startMonth', 'endMonth', 'targetAsset'];

                if (numberFields.includes(field)) {
                    const numValue = Number(value);
                    if (!isNaN(numValue)) {
                        newValue = Math.max(0, numValue); // 음수 방지
                    }
                }

                setExpenseEvents(prev => {
                    // [개선] prev가 배열이 아닐 경우를 대비하여 안전하게 처리
                    const currentEvents = Array.isArray(prev) ? prev : [];
                    return currentEvents.map((event, i) =>
                        i === index ? { ...event, [field]: newValue } : event
                    );
                });
            };
            const removeExpenseEvent = (index) => setExpenseEvents(prev => {
                // [개선] prev가 배열이 아닐 경우를 대비하여 안전하게 처리
                const currentEvents = Array.isArray(prev) ? prev : [];
                return currentEvents.filter((_, i) => i !== index);
            });
            // ===== 리밸런싱 알림 설정 함수들 =====
            const updateRebalancingAlert = (sector, type, value) => {
                setRebalancingAlerts(prev => ({
                    ...prev,
                    [sector]: { ...prev[sector], [type]: Number(value) }
                }));
            };


            const savingsPanelSectors = ['deposit','savings','investment','misc'];
            const assetsPanelSectors = ['realestate','car','misc'];
            const loanPanelSectors = ['loan'];

            const renderSummaryPanel = () => (
                <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                    <div className="md:col-span-1 bg-gradient-to-br from-blue-50 to-indigo-100 rounded-xl shadow-lg p-6">
                        <div>
                            <h2 className="text-lg font-semibold mb-2 text-gray-600">현재 총자산</h2>
                            <p className="text-3xl font-bold text-blue-600">{formatNumber(calculation.currentTotal)}만원</p>
                        </div>
                        <div className="mt-6">
                            <h2 className="text-lg font-semibold mb-2 text-gray-600">{projectionMonths}개월 후 예상 <span className="text-gray-400 text-sm">({(() => { try { const [y,m]= (baseMonth||'').split('-').map(Number); const d = new Date(y||new Date().getFullYear(), (m||1)-1, 1); d.setMonth(d.getMonth()+projectionMonths); return `${String(d.getFullYear()).slice(2)}년 ${String(d.getMonth()+1).padStart(2,'0')}월`; } catch { return ''; } })()})</span></h2>
                            <p className="text-3xl font-bold text-green-600">{formatNumber(calculation.projectedTotal)}만원</p>
                            <p className="text-sm text-gray-500 mt-1">예상 증가액: +{formatNumber(calculation.growth)}만원 ({formatPercent((calculation.growth) / Math.max(1, calculation.currentTotal) * 100)}%)</p>
                        </div>
                    </div>
                    <div className="md:col-span-1 bg-white rounded-xl shadow-lg p-6">
                        <h2 className="text-xl font-bold text-gray-800 mb-4">핵심 설정</h2>
                        <div className="space-y-4">
                            <div>
                                <label className="block text-sm font-medium text-gray-700 mb-1">월급 (만원)</label>
                                <input type="number" className="w-full border rounded-md px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500" value={monthlySalary} onChange={(e) => setMonthlySalary(Number(e.target.value))} />
                            </div>
                            <div>
                                <label className="block text-sm font-medium text-gray-700 mb-1">기준월 (계산 시작)</label>
                                <input type="month" className="w-full border rounded-md px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500" value={baseMonth} onChange={(e) => setBaseMonth(e.target.value)} />
                            </div>
                            <div className="pt-4 border-t">
                                <h3 className="text-md font-semibold text-gray-700 mb-2">데이터 관리</h3>
                                <div className="grid grid-cols-2 gap-2">
                                    <button onClick={() => setIsExportModalOpen(true)} className="flex items-center justify-center gap-2 px-3 py-2 bg-green-500 text-white text-sm font-semibold rounded-lg hover:bg-green-600 shadow-sm hover:shadow-md transition-all">
                                        <span>📤</span> 데이터 내보내기
                                    </button>
                                    <button onClick={() => setIsImportModalOpen(true)} className="flex items-center justify-center gap-2 px-3 py-2 bg-purple-500 text-white text-sm font-semibold rounded-lg hover:bg-purple-600 shadow-sm hover:shadow-md transition-all">
                                        <span>📥</span> 데이터 불러오기
                                    </button>
                                    <button onClick={saveCurrentAsset} className="col-span-2 flex items-center justify-center gap-2 px-3 py-2 bg-blue-500 text-white text-sm font-semibold rounded-lg hover:bg-blue-600 shadow-sm hover:shadow-md transition-all">
                                        <span>💾</span> 히스토리 저장
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div className="md:col-span-1 bg-white rounded-xl shadow-lg p-6">
                        <h2 className="text-xl font-bold text-gray-800 mb-4">목표 설정</h2>
                        <div className="mb-4">
                            <div className="flex border border-gray-200 rounded-lg p-1 bg-gray-100">
                                <button onClick={() => { setGoalMode('period'); setGoalSeekResult(null); }} className={`flex-1 py-2 text-sm font-semibold rounded-md transition-colors ${goalMode === 'period' ? 'bg-white text-blue-600 shadow' : 'text-gray-600 hover:bg-gray-200'}`}>
                                    기간 기준
                                </button>
                                <button onClick={() => setGoalMode('target')} className={`flex-1 py-2 text-sm font-semibold rounded-md transition-colors ${goalMode === 'target' ? 'bg-white text-blue-600 shadow' : 'text-gray-600 hover:bg-gray-200'}`}>
                                    자산 기준
                                </button>
                            </div>
                        </div>

                        <div className="space-y-4">
                            {goalMode === 'period' ? (
                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-1">예상 기간 (개월)</label>
                                    <input type="number" className="w-full border rounded-md px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500" value={projectionMonths} onChange={(e) => setProjectionMonths(Number(e.target.value))} />
                                </div>
                            ) : (
                                <div className="space-y-2">
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-1">목표 자산 (만원)</label>
                                        <input type="number" className="w-full border rounded-md px-3 py-2 focus:ring-2 focus:ring-green-500 focus:border-green-500" value={targetAmount} onChange={(e) => setTargetAmount(Number(e.target.value))} />
                                    </div>
                                    <button onClick={calculateGoalSeek} className="w-full bg-green-500 text-white px-4 py-2 rounded-lg hover:bg-green-600 font-semibold shadow-sm hover:shadow-md transition-all">
                                        달성 기간 계산
                                    </button>
                                </div>
                            )}
                            
                            {goalMode === 'target' && goalSeekResult && (
                                <div className="mt-2 p-3 bg-green-50 border border-green-200 rounded-lg">
                                    <p className="text-green-800 font-medium text-center">{goalSeekResult}</p>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );

            const renderScenarioPanel = () => (
                <div className="flex flex-col lg:flex-row lg:items-start gap-6">
                    <div className="lg:w-full lg:max-w-md">
                        <h3 className="text-lg font-semibold text-gray-700 mb-4">저장된 시나리오</h3>
                        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-1 gap-4">
                            {scenarios.map(scenario => (
                                <div key={scenario.id} className="border rounded-lg p-4">
                                    <h4 className="font-medium text-gray-900">{scenario.name}</h4>
                                    <p className="text-sm text-gray-500">{new Date(scenario.createdAt).toLocaleDateString()}</p>
                                    <div className="mt-2 flex gap-2">
                                        <button onClick={() => loadScenario(scenario)} className="flex-1 px-3 py-1 rounded text-sm bg-indigo-500 text-white hover:bg-indigo-600">불러오기</button>
                                        <button onClick={() => deleteScenario(scenario.id)} className="px-3 py-1 rounded text-sm bg-rose-500 text-white hover:bg-rose-600">삭제</button>
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                    <div className="flex-grow border-l border-gray-200 pl-6">
                        <h3 className="text-lg font-semibold text-gray-700 mb-3">시나리오 비교 (최대 3개)</h3>
                        <ScenarioCompare scenarios={scenarios} sectorInfo={sectorInfo} calculateMonthlyProjection={calculateMonthlyProjection} formatNumber={formatNumber} />
                    </div>
                </div>
            );

            const renderChartsPanel = () => (
                <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                    <div className="bg-white rounded-lg shadow p-4"><canvas ref={currentPieRef} height="300"></canvas></div>
                    <div className="bg-white rounded-lg shadow p-4"><canvas ref={projectedPieRef} height="300"></canvas></div>
                    <div className="bg-white rounded-lg shadow p-4"><canvas ref={comparisonBarRef} height="300"></canvas></div>
                </div>
            );

            const renderHistoryPanel = () => (
                <>
                    <div className="bg-gray-50 rounded-lg p-4">
                        <canvas ref={historyChartRef} height="200"></canvas>
                    </div>
                    <div className="mt-4 text-sm text-gray-600">
                        총 {assetHistory.length}개의 기록이 있습니다. 
                        최근 기록: {assetHistory[assetHistory.length - 1]?.date} {assetHistory[assetHistory.length - 1]?.time ? `(${assetHistory[assetHistory.length - 1].time.split(':').slice(0, 2).join(':')})` : ''} ({formatNumber(assetHistory[assetHistory.length - 1]?.netWorth)}만원)
                    </div>
                </>
            );

            const renderBudgetPanel = () => (
                <div className="bg-blue-50 rounded-lg shadow p-6">
                    <div className="grid grid-cols-2 sm:grid-cols-4 gap-4">
                        <div className="text-center"><div className="text-sm text-gray-600">월수입</div><div className="text-xl font-bold text-blue-600">{formatNumber(monthlySalary)}만원</div></div>
                        <div className="text-center"><div className="text-sm text-gray-600">월별 지출</div><div className="text-xl font-bold text-red-600">{formatNumber(totalMonthlyExpense)}만원</div></div>
                        <div className="text-center"><div className="text-sm text-gray-600">월납입 가능액</div><div className="text-xl font-bold text-green-600">{formatNumber(maxSectorMonthlyContrib)}만원</div></div>
                        <div className="text-center"><div className="text-sm text-gray-600">월납입 사용액</div><div className={`text-xl font-bold ${totalSectorMonthlyContrib > maxSectorMonthlyContrib ? 'text-red-600' : 'text-blue-600'}`}>{formatNumber(totalSectorMonthlyContrib)}만원</div></div>
                    </div>
                    {totalSectorMonthlyContrib > maxSectorMonthlyContrib && (<div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded my-4">⚠️ 월납입 한도를 초과했습니다. 월수입외 납입을 이용하거나 월납입을 줄여주세요.</div>)}
                    <div className="bg-white rounded-lg p-4 my-4"><h4 className="text-sm font-medium text-gray-700 mb-3">💡 잔여액 계산식</h4><div className="text-sm space-y-2"><div className="flex justify-between"><span>월수입</span><span className="font-medium text-blue-600">+{formatNumber(monthlySalary)}만원</span></div><div className="flex justify-between"><span>월별 지출</span><span className="font-medium text-red-600">-{formatNumber(totalMonthlyExpense)}만원</span></div><hr className="border-gray-200" /><div className="flex justify-between font-medium"><span>월납입 가능액</span><span className="text-green-600">{formatNumber(maxSectorMonthlyContrib)}만원</span></div><div className="text-xs text-gray-500 mt-2">현재 월납입 설정:</div>{autoDepositBreakdown.map((item, index) => (<div key={index} className="flex justify-between text-xs"><span className={`text-${sectorInfo[item.sector]?.color || 'gray'}-600`}>{sectorInfo[item.sector]?.icon} {item.name}</span><span className="font-medium">-{formatNumber(item.amount)}만원</span></div>))}<hr className="border-gray-200" /><div className="flex justify-between font-bold"><span>잔여액</span><span className="text-green-600">{formatNumber(autoDepositAmount)}만원</span></div></div></div>
                    <div className="flex flex-col sm:flex-row items-center justify-between bg-white rounded-lg p-4 gap-4 mt-4"><div className="text-center sm:text-left"><div className="text-sm text-gray-600">잔여액</div><div className="text-2xl font-bold text-green-600">{formatNumber(autoDepositAmount)}만원</div><div className="text-xs text-gray-500">월납입 가능액 {formatNumber(maxSectorMonthlyContrib)}만원 - 월납입 사용액 {formatNumber(totalSectorMonthlyContrib)}만원</div></div><div className="flex flex-col sm:flex-row items-center gap-4"><div><label className="block text-sm text-gray-600 text-center sm:text-left mb-1">월급/지출 및 잔여액 관리 계좌</label><select className="border rounded px-3 py-2" value={mainCashFlowAccount} onChange={e => setMainCashFlowAccount(e.target.value)}>{Object.values(assets).flat().filter(item => item.name !== '새 항목').map((asset, idx) => (<option key={idx} value={asset.name}>{asset.name}</option>))}</select></div></div></div>
                </div>
            );

            const renderMemoPanel = () => (
                <textarea className="w-full h-32 p-3 border rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500" placeholder="여기에 자유롭게 메모를 남겨보세요. (자동 저장됩니다)" value={memo} onChange={(e) => setMemo(e.target.value)} />
            );

            const renderRebalancePanel = () => {
                const validSectors = Object.keys(sectorInfo).filter(k=>k!=='loan');
                const defaultPct = Math.round(100 / validSectors.length);
                
                const totalTarget = validSectors.reduce((sum, key) => {
                    const value = rebalancingTargets[key];
                    const numericValue = (value === undefined || value === null) ? defaultPct : Number(value);
                    return sum + numericValue;
                }, 0);

                const handleNormalize = () => {
                    if (totalTarget === 0) return;
                    const newTargets = {};
                    validSectors.forEach(key => {
                        const value = rebalancingTargets[key];
                        const currentVal = (value === undefined || value === null) ? defaultPct : Number(value);
                        newTargets[key] = Math.round((currentVal / totalTarget) * 100);
                    });

                    const finalTotal = Object.values(newTargets).reduce((s, v) => s + v, 0);
                    const diff = 100 - finalTotal;
                    if (diff !== 0) {
                        const maxKey = Object.keys(newTargets).reduce((a, b) => newTargets[a] > newTargets[b] ? a : b);
                        newTargets[maxKey] += diff;
                    }
                    setRebalancingTargets(newTargets);
                };

                return (
                    <div className="bg-yellow-50 dark:bg-yellow-900/20 rounded-lg shadow p-6">
                        <StackedBarDisplay targets={rebalancingTargets} sectorInfo={sectorInfo} />
                        <div className="mb-4 grid grid-cols-1 lg:grid-cols-3 gap-4 text-sm">                                        
                            <div className="flex items-center gap-2">
                                <span className="text-gray-700 dark:text-gray-200 whitespace-nowrap">목표 비중 총합:</span>
                                <span className={`font-bold ${totalTarget !== 100 ? 'text-red-600 dark:text-red-400' : 'text-green-600 dark:text-green-400'}`}>
                                    {totalTarget}%
                                </span>
                                <button 
                                    onClick={handleNormalize} 
                                    className="ml-2 px-3 py-1 bg-yellow-600 text-white text-xs rounded hover:bg-yellow-700 disabled:bg-gray-400"
                                    disabled={totalTarget === 100}
                                >
                                    100% 자동조정
                                </button>
                            </div>
                        </div>
                        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                            {validSectors.map(sectorKey => {
                                const currentValue = rebalancingTargets[sectorKey] ?? defaultPct;
                                return (
                                    <div key={sectorKey} className="bg-white dark:bg-gray-800 rounded-lg p-4">
                                        <h4 className="font-medium text-gray-900 dark:text-white mb-2">{sectorInfo[sectorKey].icon} {sectorInfo[sectorKey].name}</h4>
                                        <div className="space-y-2">
                                            <div className="flex items-center gap-2">
                                                <label className="block text-xs text-gray-600 dark:text-gray-300 whitespace-nowrap">목표 비중 (%)</label>
                                                <input 
                                                    type="number" 
                                                    min="0" 
                                                    max="100" 
                                                    step="1"
                                                    className="w-full border rounded px-2 py-1 text-sm bg-white dark:bg-gray-700 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white" 
                                                    value={currentValue} 
                                                    onChange={(e)=> setRebalancingTargets(prev=> ({ ...prev, [sectorKey]: Number(e.target.value) }))} 
                                                />
                                            </div>
                                            <>
                                                <div>
                                                    <label className="block text-xs text-gray-600 dark:text-gray-300">경고 임계값 (편차 %)</label>
                                                    <input type="number" className="w-full border rounded px-2 py-1 text-sm bg-white dark:bg-gray-700 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white" value={rebalancingAlerts[sectorKey]?.warning ?? 5} onChange={(e)=> updateRebalancingAlert(sectorKey, 'warning', e.target.value)} />
                                                </div>
                                                <div>
                                                    <label className="block text-xs text-gray-600 dark:text-gray-300">위험 임계값 (편차 %)</label>
                                                    <input type="number" className="w-full border rounded px-2 py-1 text-sm bg-white dark:bg-gray-700 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white" value={rebalancingAlerts[sectorKey]?.danger ?? 10} onChange={(e)=> updateRebalancingAlert(sectorKey, 'danger', e.target.value)} />
                                                </div>
                                            </>
                                        </div>
                                    </div>
                                )
                            })}
                        </div>
                    </div>
                );
            };

            const renderAssetsPanel = () => (
                <div className="space-y-8">
                    {assetSectorOrder.map((sectorKey, index) => (
                        <div key={sectorKey} className={`bg-${sectorInfo[sectorKey].color}-50 rounded-lg shadow p-6`}>
                            <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-4 gap-4">
                                <button type="button" onClick={()=> setHiddenSectors(prev=> ({...prev, [sectorKey]: !prev[sectorKey]}))} className={`text-left text-xl font-semibold text-${sectorInfo[sectorKey].color}-700 flex items-center gap-2`}>
                                    <span>{sectorInfo[sectorKey].icon}</span>
                                    {sectorInfo[sectorKey].name}
                                    <span className="text-sm bg-white px-2 py-1 rounded">
                                        현재: {formatPercent(currentSectorTotals[sectorKey]?.percentage || 0)}% →
                                        예상: {formatPercent(projectedSectorTotals[sectorKey]?.percentage || 0)}%
                                    </span>
                                    <span className="ml-2 text-xs text-gray-500">{hiddenSectors[sectorKey] ? '(접힘)' : '(펼침)'}</span>
                                </button>
                                <div className="flex items-center gap-2">
                                    <div className="flex items-center gap-1 bg-white rounded-full p-1">
                                        <button onClick={() => moveAssetSector(sectorKey, -1)} disabled={index === 0} className="p-1 rounded-full hover:bg-gray-100 disabled:opacity-30 disabled:cursor-not-allowed" title="위로 이동">
                                            <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M5 15l7-7 7 7" /></svg>
                                        </button>
                                        <button onClick={() => moveAssetSector(sectorKey, 1)} disabled={index === assetSectorOrder.length - 1} className="p-1 rounded-full hover:bg-gray-100 disabled:opacity-30 disabled:cursor-not-allowed" title="아래로 이동">
                                            <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7" /></svg>
                                        </button>
                                    </div>
                                    <button onClick={() => addAsset(sectorKey)} className={`bg-${sectorInfo[sectorKey].color}-500 text-white px-4 py-2 rounded hover:bg-${sectorInfo[sectorKey].color}-600 whitespace-nowrap`}>
                                        + 항목 추가
                                    </button>
                                </div>
                            </div>
                            {!hiddenSectors[sectorKey] && (
                            <div className="space-y-4">
                                {assets[sectorKey]?.map((asset, index) => {
                                    const projectedAmount = calculation.projected[sectorKey]?.[index]?.amount || 0;
                                    const sectorTotal = projectedSectorTotals[sectorKey]?.amount || 1;
                                    const assetPercentage = (projectedAmount / sectorTotal * 100);
                                    
                                    const nameRef = el => assetInputRefs.current[`${sectorKey}-${index}-name`] = el;
                                    const amountRef = el => assetInputRefs.current[`${sectorKey}-${index}-amount`] = el;
                                    const monthlyContribRef = el => assetInputRefs.current[`${sectorKey}-${index}-monthlyContrib`] = el;

                                    return (
                                        <div key={index} className="bg-white dark:bg-gray-800 rounded-lg p-4 shadow-sm">
                                            {sectorKey !== 'loan' && (
                                                <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-8 gap-3 items-center">
                                                    <input ref={nameRef} type="text" placeholder="항목명" className="border rounded px-2 py-1 bg-white dark:bg-gray-700 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white" value={asset.name} onChange={(e) => updateAsset(sectorKey, index, 'name', e.target.value)} />
                                                    <div>
                                                        <label className="block text-xs text-gray-500 dark:text-gray-400">현재금액</label>
                                                        <input ref={amountRef} type="number" className="w-full border rounded px-2 py-1 bg-white dark:bg-gray-700 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white" value={asset.amount} onChange={(e) => updateAsset(sectorKey, index, 'amount', e.target.value)} />
                                                    </div>
                                                    <div>
                                                        <label className="block text-xs text-gray-500 dark:text-gray-400">수익률(%)</label>
                                                        <input type="number" step="0.1" className="w-full border rounded px-2 py-1 bg-white dark:bg-gray-700 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white" value={asset.rate} onChange={(e) => updateAsset(sectorKey, index, 'rate', e.target.value)} />
                                                    </div>
                                                    <div>
                                                        <label className="block text-xs text-gray-500 dark:text-gray-400">수수료/세금(%)</label>
                                                        <input type="number" step="0.001" className="w-full border rounded px-2 py-1 bg-white dark:bg-gray-700 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white" value={asset.feeRate ?? 0} onChange={(e) => updateAsset(sectorKey, index, 'feeRate', e.target.value)} />
                                                    </div>
                                                    <div>
                                                        <label className="block text-xs text-gray-500 dark:text-gray-400">월납입</label>
                                                        <input ref={monthlyContribRef} type="number" className="w-full border rounded px-2 py-1 bg-white dark:bg-gray-700 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white" value={asset.monthlyContrib} onChange={(e) => updateAsset(sectorKey, index, 'monthlyContrib', e.target.value)} />
                                                    </div>
                                                    <div>
                                                        <label className="block text-xs text-gray-500 dark:text-gray-400">월수입외 납입</label>
                                                        <input type="number" min="0" className="w-full border rounded px-2 py-1 bg-white dark:bg-gray-700 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white" value={asset.extraContrib} onChange={(e) => updateAsset(sectorKey, index, 'extraContrib', e.target.value)} />
                                                    </div>
                                                    {asset.extraContrib > 0 && (
                                                        <div>
                                                            <label className="block text-xs text-gray-500 dark:text-gray-400">출금계좌</label>
                                                            <select className="w-full border rounded px-2 py-1 text-xs bg-white dark:bg-gray-700 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white" value={asset.extraFrom} onChange={(e) => updateAsset(sectorKey, index, 'extraFrom', e.target.value)}>
                                                                {Object.values(assets).flat().filter(a => a.name !== asset.name).map((d, i) => (
                                                                    <option key={i} value={d.name}>{d.name}</option>
                                                                ))}
                                                            </select>
                                                        </div>
                                                    )}
                                                    <div className="text-sm">
                                                        <div className="text-gray-600 dark:text-gray-300">예상: {formatNumber(projectedAmount)}만원</div>
                                                        <div className={`text-gray-500 dark:text-gray-400`}>
                                                            비중: <span className={`${(() => {
                                                                const validSectorTotal = projectedSectorTotals[sectorKey]?.amount || 0;
                                                                const target = rebalancingTargets[sectorKey] ?? Math.round(100 / Object.keys(sectorInfo).length);
                                                                const diff = Math.abs(projectedSectorTotals[sectorKey]?.percentage - target);
                                                                const warn = rebalancingAlerts[sectorKey]?.warning ?? 5;
                                                                const danger = rebalancingAlerts[sectorKey]?.danger ?? 10;
                                                                if (diff >= danger) return 'text-red-500';
                                                                if (diff >= warn) return 'text-yellow-500';
                                                                return 'text-green-600 dark:text-green-400';
                                                            })()}`}>{
                                                                (() => {
                                                                    const validSectorTotal = projectedSectorTotals[sectorKey]?.amount || 0;
                                                                    const assetPercentage = (validSectorTotal > 0) ? (projectedAmount / validSectorTotal * 100) : 0;
                                                                    return formatPercent(assetPercentage);
                                                                })()
                                                            }%</span>
                                                        </div>
                                                    </div>
                                                    <button onClick={() => removeAsset(sectorKey, index)} className="text-red-500 hover:text-red-700 whitespace-nowrap">삭제</button>
                                                </div>
                                            )}

                                            {sectorKey === 'loan' && (
                                                <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-9 gap-3 items-center">
                                                    <input ref={nameRef} type="text" placeholder="항목명" className="border rounded px-2 py-1 bg-white dark:bg-gray-700 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white" value={asset.name} onChange={(e) => updateAsset(sectorKey, index, 'name', e.target.value)} />
                                                    <div>
                                                        <label className="block text-xs text-gray-500 dark:text-gray-400">현재잔액</label>
                                                        <input ref={amountRef} type="number" className="w-full border rounded px-2 py-1 bg-white dark:bg-gray-700 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white" value={asset.amount} onChange={(e) => updateAsset(sectorKey, index, 'amount', e.target.value)} />
                                                    </div>
                                                    <div>
                                                        <label className="block text-xs text-gray-500 dark:text-gray-400">이자율(%)</label>
                                                        <input type="number" step="0.1" className="w-full border rounded px-2 py-1 bg-white dark:bg-gray-700 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white" value={asset.rate} onChange={(e) => updateAsset(sectorKey, index, 'rate', e.target.value)} />
                                                    </div>
                                                    <div>
                                                        <label className="block text-xs text-gray-500 dark:text-gray-400">월 상환액</label>
                                                        <input ref={monthlyContribRef} type="number" className="w-full border rounded px-2 py-1 bg-white dark:bg-gray-700 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white" value={asset.monthlyContrib} onChange={(e) => updateAsset(sectorKey, index, 'monthlyContrib', e.target.value)} />
                                                    </div>
                                                    <div>
                                                        <label className="block text-xs text-gray-500 dark:text-gray-400">만기(개월)</label>
                                                        <input type="number" className="w-full border rounded px-2 py-1 bg-white dark:bg-gray-700 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white" value={asset.maturityMonth ?? 12} onChange={(e) => updateAsset(sectorKey, index, 'maturityMonth', e.target.value)} />
                                                    </div>
                                                    <div>
                                                        <label className="block text-xs text-gray-500 dark:text-gray-400">상환방식</label>
                                                        <select 
                                                            className="w-full border rounded px-2 py-1 text-xs bg-white dark:bg-gray-700 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white" 
                                                            value={asset.repaymentMethod} 
                                                            onChange={(e) => updateAsset(sectorKey, index, 'repaymentMethod', e.target.value)}
                                                        >
                                                            <option value="원리금균등">원리금균등</option>
                                                            <option value="원금균등">원금균등</option>
                                                            <option value="만기일시">만기일시</option>
                                                        </select>
                                                    </div>
                                                    <div>
                                                        <label className="block text-xs text-gray-500 dark:text-gray-400">상환계좌 (월)</label>
                                                        <select 
                                                            className="w-full border rounded px-2 py-1 text-xs bg-white dark:bg-gray-700 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white" 
                                                            value={asset.repaymentAccount} 
                                                            onChange={(e) => updateAsset(sectorKey, index, 'repaymentAccount', e.target.value)}
                                                        >
                                                            {Object.values(assets).flat().filter(a => a.name !== asset.name).map((d, i) => (
                                                                <option key={i} value={d.name}>{d.name}</option>
                                                            ))}
                                                        </select>
                                                    </div>
                                                    <div>
                                                        <label className="block text-xs text-gray-500 dark:text-gray-400">추가 상환 (월수입외)</label>
                                                        <input type="number" min="0" className="w-full border rounded px-2 py-1 bg-white dark:bg-gray-700 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white" value={asset.extraContrib} onChange={(e) => updateAsset(sectorKey, index, 'extraContrib', e.target.value)} />
                                                    </div>
                                                    {asset.extraContrib > 0 && (
                                                        <div>
                                                            <label className="block text-xs text-gray-500 dark:text-gray-400">출금계좌 (추가)</label>
                                                            <select className="w-full border rounded px-2 py-1 text-xs bg-white dark:bg-gray-700 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white" value={asset.extraFrom} onChange={(e) => updateAsset(sectorKey, index, 'extraFrom', e.target.value)}>
                                                                {Object.values(assets).flat().filter(a => a.name !== asset.name).map((d, i) => (
                                                                    <option key={i} value={d.name}>{d.name}</option>
                                                                ))}
                                                            </select>
                                                        </div>
                                                    )}
                                                    <div className="text-sm">
                                                        <div className="text-gray-600 dark:text-gray-300">예상잔액: {formatNumber(projectedAmount)}만원</div>
                                                    </div>
                                                    <button onClick={() => removeAsset(sectorKey, index)} className="text-red-500 hover:text-red-700 whitespace-nowrap">삭제</button>
                                                </div>
                                            )}
                                        </div>
                                    );
                                })}
                            </div>
                            )}
                        </div>
                    ))}
                </div>
            );

            const renderExpensesPanel = () => (
                <div className="bg-red-50 rounded-lg shadow p-6">
                    <div className="flex justify-between items-center mb-4">
                        <h3 className="text-lg font-semibold text-red-700">월별 지출</h3>
                        <button onClick={addExpense} className="bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600 whitespace-nowrap">+ 지출 추가</button>
                    </div>
                    <div className="space-y-3">
                        {monthlyExpenses.map((expense, index) => (
                            <div key={index} className="bg-white rounded-lg p-3 shadow-sm">
                                <div className="grid grid-cols-1 sm:grid-cols-4 gap-3 items-center">
                                    <input type="text" placeholder="지출명" className="border rounded px-2 py-1" value={expense.name} onChange={(e) => updateExpense(index, 'name', e.target.value)} />
                                    <input type="number" placeholder="금액(만원)" className="border rounded px-2 py-1" value={expense.amount} onChange={(e) => updateExpense(index, 'amount', e.target.value)} />
                                    <div className="text-sm text-gray-600">연간: {formatNumber(expense.amount * projectionMonths)}만원</div>
                                    <button onClick={() => removeExpense(index)} className="text-red-500 hover:text-red-700 whitespace-nowrap">삭제</button>
                                </div>
                            </div>
                        ))}
                    </div>
                </div>
            );

            const renderEventsPanel = () => (
                <div className="space-y-6">
                    <div className="bg-green-50 rounded-lg shadow p-6">
                        <div className="flex justify-between items-center mb-4">
                            <h3 className="text-lg font-semibold text-green-700 flex items-center gap-2">💰 이벤트성 수입 (성과급, 용돈 등)</h3>
                            <button onClick={addIncomeEvent} className="bg-green-500 text-white px-4 py-2 rounded-lg hover:bg-green-600 whitespace-nowrap">+ 수입 이벤트 추가</button>
                        </div>
                        <div className="text-xs text-gray-600 mb-4 bg-white p-3 rounded-lg border border-green-100">
                            💡 항목 설명: 이벤트명 | 금액 | 시작 월 | 종료 월 | 입금처(섹터/계좌)
                            <div className="mt-1 text-gray-500">
                                예: 3~8개월 입력 시, 기준월 기준 <strong>{(() => { 
                                    try { 
                                        const baseMonthStr = baseMonth || '';
                                        if (!baseMonthStr) return '기준월 설정 필요';
                                        const [y,m] = baseMonthStr.split('-').map(Number);
                                        if (!y || !m) return '기준월 형식 오류';
                                        const d = new Date(y, m-1, 1);
                                        if (isNaN(d.getTime())) return '날짜 계산 오류';
                                        const fmt = (dt) => `${String(dt.getFullYear()).slice(2)}년 ${String(dt.getMonth()+1).padStart(2,'0')}월`;
                                        const s = new Date(d);
                                        s.setMonth(s.getMonth() + 3 - 1);
                                        const e = new Date(d);
                                        e.setMonth(e.getMonth() + 8 - 1);
                                        if (isNaN(s.getTime()) || isNaN(e.getTime())) return '날짜 계산 오류';
                                        return `${fmt(s)} ~ ${fmt(e)}`;
                                    } catch (error) { 
                                        console.error('Date calculation error:', error);
                                        return '날짜 계산 오류';
                                    } 
                                })()}</strong>
                            </div>
                        </div>
                        <div className="space-y-4">
                            {incomeEvents && incomeEvents.length > 0 ? incomeEvents.map((event, index) => {
                                if (!event || typeof event !== 'object') {
                                    console.warn('Invalid event data at index:', index);
                                    return null;
                                }
                                
                                return (
                                <div key={index} className="bg-white rounded-lg p-4 shadow-sm border">
                                    <div className="grid grid-cols-1 md:grid-cols-4 lg:grid-cols-8 gap-4 items-end">
                                        <div className="md:col-span-2 lg:col-span-2">
                                            <label className="block text-sm font-medium text-gray-700 mb-1">이벤트명</label>
                                            <input type="text" placeholder="이벤트명" className="w-full border rounded-md px-3 py-2" value={event.name} onChange={(e) => updateIncomeEvent(index, 'name', e.target.value)} />
                                        </div>
                                        <div className="md:col-span-2 lg:col-span-1">
                                            <label className="block text-sm font-medium text-gray-700 mb-1">금액</label>
                                            <input type="number" placeholder="금액" className="w-full border rounded-md px-3 py-2" value={event.amount} onChange={(e) => updateIncomeEvent(index, 'amount', e.target.value)} />
                                        </div>
                                        <div className="md:col-span-2 lg:col-span-1">
                                            <label className="block text-sm font-medium text-gray-700 mb-1">시작 월</label>
                                            <input type="number" placeholder="개월차" className="w-full border rounded-md px-3 py-2" value={event.startMonth} onChange={(e) => updateIncomeEvent(index, 'startMonth', e.target.value)} />
                                            <div className="text-xs text-gray-500 mt-1">{(() => { 
                                                try { 
                                                    const [y,m] = (baseMonth||'').split('-').map(Number);
                                                    const d = new Date(y, m-1, 1);
                                                    const s = new Date(d);
                                                    s.setMonth(s.getMonth() + Number(event.startMonth || 0) - 1);
                                                    return `${String(s.getFullYear()).slice(2)}년 ${String(s.getMonth()+1).padStart(2,'0')}월 부터`;
                                                } catch { return ''; } 
                                            })()}</div>
                                        </div>
                                        <div className="md:col-span-2 lg:col-span-1">
                                            <label className="block text-sm font-medium text-gray-700 mb-1">종료 월</label>
                                            <input type="number" placeholder="개월차" className="w-full border rounded-md px-3 py-2" value={event.endMonth} onChange={(e) => updateIncomeEvent(index, 'endMonth', e.target.value)} />
                                            <div className="text-xs text-gray-500 mt-1">{(() => { 
                                                try { 
                                                    const [y,m] = (baseMonth||'').split('-').map(Number);
                                                    const d = new Date(y, m-1, 1);
                                                    const e = new Date(d);
                                                    e.setMonth(e.getMonth() + Number(event.endMonth || 0) - 1);
                                                    return `${String(e.getFullYear()).slice(2)}년 ${String(e.getMonth()+1).padStart(2,'0')}월 까지`;
                                                } catch { return ''; } 
                                            })()}</div>
                                        </div>
                                        <div className="md:col-span-3 lg:col-span-2">
                                            <label className="block text-sm font-medium text-gray-700 mb-1">입금처</label>
                                            <div className="grid grid-cols-2 gap-2">
                                                <select className="w-full border rounded-md px-3 py-2" value={event.targetSector} onChange={(e) => updateIncomeEvent(index, 'targetSector', e.target.value)}>
                                                    {Object.keys(sectorInfo).map(key => (
                                                        <option key={key} value={key}>{sectorInfo[key].name}</option>
                                                    ))}
                                                </select>
                                                <select className="w-full border rounded-md px-3 py-2" value={event.targetAsset} onChange={(e) => updateIncomeEvent(index, 'targetAsset', e.target.value)}>
                                                    {assets[event.targetSector]?.map((asset, assetIndex) => (
                                                        <option key={assetIndex} value={assetIndex}>{asset.name}</option>
                                                    ))}
                                                </select>
                                            </div>
                                        </div>
                                        <div className="md:col-span-1 lg:col-span-1 flex items-end justify-center h-full">
                                            <button onClick={() => removeIncomeEvent(index)} className="text-red-500 hover:text-red-700 font-medium whitespace-nowrap">삭제</button>
                                        </div>
                                    </div>
                                </div>
                                );
                            }) : (
                                <div className="text-center text-gray-500 py-8">
                                    <p>이벤트성 수입이 없습니다.</p>
                                    <p className="text-sm">위의 "+ 수입 이벤트 추가" 버튼을 클릭하여 추가하세요.</p>
                                </div>
                            )}
                        </div>
                    </div>
                    <div className="bg-orange-50 rounded-lg shadow p-6">
                        <div className="flex justify-between items-center mb-4">
                            <h3 className="text-lg font-semibold text-orange-700 flex items-center gap-2">🛒 이벤트성 지출 (여행, 대형구매 등)</h3>
                            <button onClick={addExpenseEvent} className="bg-orange-500 text-white px-4 py-2 rounded-lg hover:bg-orange-600 whitespace-nowrap">+ 지출 이벤트 추가</button>
                        </div>
                        <div className="text-xs text-gray-600 mb-4 bg-white p-3 rounded-lg border border-orange-100">
                            💡 항목 설명: 이벤트명 | 금액 | 시작 월 | 종료 월 | 출금처(섹터/계좌)
                            <div className="mt-1 text-gray-500">
                                예: 2~5개월 입력 시, 기준월 기준 <strong>{(() => { try { const [y,m]= (baseMonth||'').split('-').map(Number); const d=new Date(y||new Date().getFullYear(),(m||1)-1,1); const fmt=(dt)=> `${String(dt.getFullYear()).slice(2)}년 ${String(dt.getMonth()+1).padStart(2,'0')}월`; const s=new Date(d); s.setMonth(s.getMonth()+2-1); const e=new Date(d); e.setMonth(e.getMonth()+5-1); return `${fmt(s)} ~ ${fmt(e)}`; } catch { return ''; } })()}</strong>
                            </div>
                        </div>
                        <div className="space-y-4">
                            {expenseEvents.map((event, index) => (
                                <div key={index} className="bg-white rounded-lg p-4 shadow-sm border">
                                    <div className="grid grid-cols-1 md:grid-cols-4 lg:grid-cols-8 gap-4 items-end">
                                        <div className="md:col-span-2 lg:col-span-2">
                                            <label className="block text-sm font-medium text-gray-700 mb-1">이벤트명</label>
                                            <input type="text" placeholder="이벤트명" className="w-full border rounded-md px-3 py-2" value={event.name} onChange={(e) => updateExpenseEvent(index, 'name', e.target.value)} />
                                        </div>
                                        <div className="md:col-span-2 lg:col-span-1">
                                            <label className="block text-sm font-medium text-gray-700 mb-1">금액</label>
                                            <input type="number" placeholder="금액" className="w-full border rounded-md px-3 py-2" value={event.amount} onChange={(e) => updateExpenseEvent(index, 'amount', e.target.value)} />
                                        </div>
                                        <div className="md:col-span-2 lg:col-span-1">
                                            <label className="block text-sm font-medium text-gray-700 mb-1">시작 월</label>
                                            <input type="number" placeholder="개월차" className="w-full border rounded-md px-3 py-2" value={event.startMonth} onChange={(e) => updateExpenseEvent(index, 'startMonth', e.target.value)} />
                                            <div className="text-xs text-gray-500 mt-1">{(() => { 
                                                try { 
                                                    const [y,m] = (baseMonth||'').split('-').map(Number);
                                                    const d = new Date(y, m-1, 1);
                                                    const s = new Date(d);
                                                    s.setMonth(s.getMonth() + Number(event.startMonth || 0) - 1);
                                                    return `${String(s.getFullYear()).slice(2)}년 ${String(s.getMonth()+1).padStart(2,'0')}월 부터`;
                                                } catch { return ''; } 
                                            })()}</div>
                                        </div>
                                        <div className="md:col-span-2 lg:col-span-1">
                                            <label className="block text-sm font-medium text-gray-700 mb-1">종료 월</label>
                                            <input type="number" placeholder="개월차" className="w-full border rounded-md px-3 py-2" value={event.endMonth} onChange={(e) => updateExpenseEvent(index, 'endMonth', e.target.value)} />
                                            <div className="text-xs text-gray-500 mt-1">{(() => { 
                                                try { 
                                                    const [y,m] = (baseMonth||'').split('-').map(Number);
                                                    const d = new Date(y, m-1, 1);
                                                    const e = new Date(d);
                                                    e.setMonth(e.getMonth() + Number(event.endMonth || 0) - 1);
                                                    return `${String(e.getFullYear()).slice(2)}년 ${String(e.getMonth()+1).padStart(2,'0')}월 까지`;
                                                } catch { return ''; } 
                                            })()}</div>
                                        </div>
                                        <div className="md:col-span-3 lg:col-span-2">
                                            <label className="block text-sm font-medium text-gray-700 mb-1">출금처</label>
                                            <div className="grid grid-cols-2 gap-2">
                                                <select className="w-full border rounded-md px-3 py-2" value={event.targetSector || 'deposit'} onChange={(e) => updateExpenseEvent(index, 'targetSector', e.target.value)}>
                                                    {Object.keys(sectorInfo).map(key => (
                                                        <option key={key} value={key}>{sectorInfo[key].name}</option>
                                                    ))}
                                                </select>
                                                <select className="w-full border rounded-md px-3 py-2" value={event.targetAsset || 0} onChange={(e) => updateExpenseEvent(index, 'targetAsset', e.target.value)}>
                                                    {assets[event.targetSector || 'deposit']?.map((asset, assetIndex) => (
                                                        <option key={assetIndex} value={assetIndex}>{asset.name}</option>
                                                    ))}
                                                </select>
                                            </div>
                                        </div>
                                        <div className="md:col-span-1 lg:col-span-1 flex items-end justify-center h-full">
                                            <button onClick={() => removeExpenseEvent(index)} className="text-red-500 hover:text-red-700 font-medium whitespace-nowrap">삭제</button>
                                        </div>
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );

            const renderFunctions = { renderSummaryPanel, renderScenarioPanel, renderChartsPanel, renderHistoryPanel, renderBudgetPanel, renderMemoPanel, renderRebalancePanel, renderAssetsPanel, renderExpensesPanel, renderEventsPanel };

            return (
                calculation.error ? (
                    <div className="flex items-center justify-center min-h-screen bg-red-50 text-red-700">
                        <div className="text-center p-8 bg-white rounded-lg shadow-md">
                            <h2 className="text-2xl font-bold mb-2">계산 오류 발생</h2>
                            <p>입력값을 확인하거나 설정을 초기화해주세요.</p>
                            <p className="text-sm text-gray-500 mt-4">{typeof calculation.error === 'string' ? calculation.error : '알 수 없는 오류'}</p>
                        </div>
                    </div>
                ) : (
                    <div className="min-h-screen bg-gray-50">
                    <div className="sticky top-0 z-50 bg-white shadow-sm border-b">
                        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                            <div className="flex justify-between items-center h-16">
                                <h1 id="app-title" className="text-xl sm:text-2xl font-bold text-gray-900 cursor-pointer" onClick={cycleDisplayMode} title="클릭하여 사용자/프라이빗/데모 모드 전환">
                                    자산 플래너 {titleText}
                                </h1>
                                <div className="hidden sm:flex items-center gap-2 sm:gap-4">
                                    <button onClick={saveToPDF} className="inline-flex items-center px-3 py-2 border border-transparent text-sm leading-4 font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700">📄 PDF 저장</button>
                                    <button onClick={saveScenario} className="inline-flex items-center px-3 py-2 border border-gray-300 text-sm leading-4 font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50">💾 시나리오 저장</button>
                                    <button onClick={saveAsDefault} className="inline-flex items-center px-3 py-2 border border-blue-300 text-sm leading-4 font-medium rounded-md text-blue-700 bg-white hover:bg-blue-50">⭐ 기본값 저장</button>
                                    <button onClick={loadCustomDefault} className="inline-flex items-center px-3 py-2 border border-gray-300 text-sm leading-4 font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50">↩️ 기본값 불러오기</button>
                                </div>
                                <div className="sm:hidden relative">
                                    <details className="relative">
                                        <summary className="list-none inline-flex items-center px-3 py-2 border rounded-md bg-white text-gray-700">☰ 메뉴</summary>
                                        <div className="absolute right-0 mt-2 w-48 bg-white border rounded-md shadow-md z-50 p-2 space-y-2">
                                            <button onClick={saveToPDF} className="w-full text-left px-3 py-2 rounded hover:bg-gray-100">📄 PDF 저장</button>
                                            <button onClick={saveScenario} className="w-full text-left px-3 py-2 rounded hover:bg-gray-100">💾 시나리오 저장</button>
                                            <button onClick={saveAsDefault} className="w-full text-left px-3 py-2 rounded hover:bg-gray-100">⭐ 기본값 저장</button>
                                            <button onClick={loadCustomDefault} className="w-full text-left px-3 py-2 rounded hover:bg-gray-100">↩️ 기본값 불러오기</button>
                                        </div>
                                    </details>
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* ===== 메인 콘텐츠 ===== */}
                    <div id="dashboard-content" className="p-4 sm:p-6 max-w-7xl mx-auto space-y-8">
                        <div className="space-y-8">
                            {layoutOrder.map((panelId, index) => {
                                const panelProps = {
                                    key: panelId,
                                    id: panelId,
                                    moveUp: () => movePanel(panelId, -1),
                                    moveDown: () => movePanel(panelId, 1),
                                    isFirst: index === 0,
                                    isLast: index === layoutOrder.length - 1,
                                    isCollapsed: !!panelCollapseState[panelId],
                                    onToggle: () => togglePanelCollapse(panelId),
                                };

                                const { renderSummaryPanel, renderScenarioPanel, renderChartsPanel, renderHistoryPanel, renderBudgetPanel, renderMemoPanel, renderRebalancePanel, renderAssetsPanel, renderExpensesPanel, renderEventsPanel } = renderFunctions;

                                switch (panelId) {
                                    case 'summary':
                                        return (
                                            <PanelWrapper {...panelProps} title="📊 요약 및 핵심 설정">
                                                {renderSummaryPanel()}
                                            </PanelWrapper>
                                        );
                                    case 'scenario':
                                        return scenarios.length > 0 && (
                                            <PanelWrapper key={panelId} {...panelProps} title="🔀 시나리오 비교">
                                                {renderScenarioPanel()}
                                            </PanelWrapper>
                                        );
                                    case 'charts':
                                        return (
                                            <PanelWrapper key={panelId} {...panelProps} title="🍩 포트폴리오 분석 차트">
                                                <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                                                    <div className="bg-white rounded-lg shadow p-4"><canvas ref={currentPieRef} height="300"></canvas></div>
                                                    <div className="bg-white rounded-lg shadow p-4"><canvas ref={projectedPieRef} height="300"></canvas></div>
                                                    <div className="bg-white rounded-lg shadow p-4"><canvas ref={comparisonBarRef} height="300"></canvas></div>
                                                </div>
                                            </PanelWrapper>
                                        );
                                    case 'history':
                                        return assetHistory.length > 0 && (
                                            <PanelWrapper key={panelId} {...panelProps} title="📈 자산 히스토리">
                                                {renderHistoryPanel()}
                                            </PanelWrapper>
                                        );
                                    case 'budget':
                                        return (
                                            <PanelWrapper key={panelId} {...panelProps} title="💰 월납입 예산 관리">
                                                {renderBudgetPanel()}
                                            </PanelWrapper>
                                        );
                                    case 'memo':
                                        return (
                                            <PanelWrapper key={panelId} {...panelProps} title="📝 메모">
                                                {renderMemoPanel()}
                                            </PanelWrapper>
                                        );
                                    case 'rebalance':
                                        return (
                                            <PanelWrapper key={panelId} {...panelProps} title="⚠️ 리밸런싱 설정">
                                                {renderRebalancePanel()}
                                            </PanelWrapper>
                                        );
                                    case 'assets':
                                        return (
                                            <PanelWrapper key={panelId} {...panelProps} title="🏦 자산 상세 입력">
                                                {renderAssetsPanel()}
                                            </PanelWrapper>
                                        );
                                    case 'expenses':
                                        return (
                                            <PanelWrapper key={panelId} {...panelProps} title="💸 월별 지출 관리">
                                                {renderExpensesPanel()}
                                            </PanelWrapper>
                                        );
                                    case 'events':
                                        return (
                                            <PanelWrapper key={panelId} {...panelProps} title="🎉 이벤트 관리">
                                                {renderEventsPanel()}
                                            </PanelWrapper>
                                        );
                                    default: return null;
                                }
                            })}
                            {/* 상세 분석 테이블 (패널화 되지 않음) */}
                            <PanelWrapper id="detail-analysis" title="🔍 상세 분석" isCollapsed={!!panelCollapseState['detail-analysis']} onToggle={() => togglePanelCollapse('detail-analysis')}>
                                <div className="overflow-x-auto">
                                    <table className="w-full text-sm">
                                        <thead className="bg-gray-100">
                                            <tr>
                                                <th className="p-3 text-left">섹터/항목</th>
                                                <th className="p-3 text-right">현재 금액</th>
                                                <th className="p-3 text-right">예상 금액</th>
                                                <th className="p-3 text-right">증감률</th>
                                                <th className="p-3 text-right">현재 비중</th>
                                                <th className="p-3 text-right">예상 비중</th>
                                                <th className="p-3 text-right">목표 비중</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {Object.keys(sectorInfo).map(sectorKey => {
                                                const current = currentSectorTotals[sectorKey] || { amount: 0, percentage: 0 };
                                                const projected = projectedSectorTotals[sectorKey] || { amount: 0, percentage: 0 };
                                                const growthRate = current.amount > 0 ? ((projected.amount - current.amount) / current.amount * 100) : 0;
                                                const rebalanceStatus = getRebalanceStatus(sectorKey, projected.percentage);
                                                const targetPct = (rebalancingTargets[sectorKey] ?? Math.round(100 / Object.keys(sectorInfo).length));
                                                
                                                return (
                                                    <React.Fragment key={sectorKey}>
                                                        <tr className={`border-t bg-${sectorInfo[sectorKey].color}-50 ${rebalanceStatus}`}>
                                                            <td className="p-3 font-semibold">
                                                                {sectorInfo[sectorKey].icon} {sectorInfo[sectorKey].name}
                                                            </td>
                                                            <td className="p-3 text-right">{formatNumber(current.amount)}</td>
                                                            <td className="p-3 text-right">{formatNumber(projected.amount)}</td>
                                                            <td className={`p-3 text-right ${growthRate >= 0 ? 'text-green-600' : 'text-red-600'}`}>{formatPercent(growthRate)}%</td>
                                                            <td className="p-3 text-right">{formatPercent(current.percentage)}%</td>
                                                            <td className="p-3 text-right">{formatPercent(projected.percentage)}%</td>
                                                            <td className="p-3 text-right">{formatPercent(targetPct)}%</td>
                                                        </tr>
                                                        {assets[sectorKey]?.map((asset, idx) => {
                                                            const projectedAmount = calculation.projected[sectorKey]?.[idx]?.amount || 0;
                                                            const assetGrowth = projectedAmount - asset.amount;
                                                            const assetGrowthRate = asset.amount > 0 ? (assetGrowth / asset.amount * 100) : 0;
                                                            const sectorTotal = projected.amount || 1;
                                                            const currentAssetPercentageInPortfolio = (currentGrossTotal > 0) ? (asset.amount / currentGrossTotal * 100) : 0;
                                                            const assetPercentageInPortfolio = (projectedAmount / projectedGrossTotal * 100);
                                                            const currentAssetPercentageInSector = (current.amount > 0) ? (asset.amount / current.amount * 100) : 0;
                                                            const projectedAssetPercentageInSector = (projected.amount > 0) ? (projectedAmount / projected.amount * 100) : 0;
                                                            
                                                            return (
                                                                <tr key={`${sectorKey}-${idx}`} className="border-t bg-gray-50">
                                                                    <td className="p-3 pl-8 text-sm">└ {asset.name}</td>
                                                                    <td className="p-3 text-right text-sm">{formatNumber(asset.amount)}</td>
                                                                    <td className="p-3 text-right text-sm">{formatNumber(projectedAmount)}</td>
                                                                    <td className={`p-3 text-right text-sm ${assetGrowthRate >= 0 ? 'text-green-600' : 'text-red-600'}`}>{formatPercent(assetGrowthRate)}%</td>
                                                                    <td className="p-3 text-right text-sm">
                                                                        {sectorKey !== 'loan' ? `${formatPercent(currentAssetPercentageInPortfolio)}% (${formatPercent(currentAssetPercentageInSector)}%)` : '-'}
                                                                    </td>
                                                                    <td className="p-3 text-right text-sm">
                                                                        {sectorKey !== 'loan' ? `${formatPercent(assetPercentageInPortfolio)}% (${formatPercent(projectedAssetPercentageInSector)}%)` : '-'}
                                                                    </td>
                                                                    <td className="p-3 text-right text-sm">-</td>
                                                                </tr>
                                                            );
                                                        })}
                                                    </React.Fragment>
                                                );
                                            })}
                                            <tr className="border-t-2 border-gray-400 bg-gray-100">
                                                <td className="p-3 font-bold">총계</td>
                                                <td className="p-3 text-right font-bold">{formatNumber(calculation.currentTotal)}</td>
                                                <td className="p-3 text-right font-bold">{formatNumber(calculation.projectedTotal)}</td>
                                                <td className="p-3 text-right font-bold text-green-600">{formatPercent(calculation.growth / calculation.currentTotal * 100)}%</td>
                                                <td className="p-3 text-right font-bold">100.0%</td>
                                                <td className="p-3 text-right font-bold">100.0%</td>
                                                <td className="p-3 text-right font-bold">100.0%</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                            </PanelWrapper>

                        {/* ===== 가정사항 ===== */}
                        <PanelWrapper id="assumptions" title="💡 계산 가정사항" isCollapsed={!!panelCollapseState['assumptions']} onToggle={() => togglePanelCollapse('assumptions')}>
                            <div className="bg-blue-50 rounded-lg p-4 text-sm text-gray-700">
                                <ul className="list-disc list-inside space-y-1">
                                    <li>수익률은 월복리로 계산됩니다.</li>
                                    <li>{applyTax ? '배당소득세(15.4%) 포함 세후 수익률 적용' : '배당소득세 제외 세전 수익률 적용'}</li>
                                    <li>이벤트성 수입은 지정된 계좌에 입금되며, 이벤트성 지출은 생활비통장에서 차감됩니다.</li>
                                    <li>월수입외 납입은 지정된 출금통장에서 차감됩니다.</li>
                                    <li>리밸런싱: 경고(노란색), 위험(빨간색) 임계값에 따라 표시됩니다.</li>
                                </ul>
                            </div>
                        </PanelWrapper>
                        </div>

                        {/* ===== 모바일 버튼 ===== */}
                        <div className="sm:hidden flex flex-col gap-2">
                            <button onClick={saveToPDF} className="w-full bg-blue-600 text-white py-3 rounded-lg font-medium">
                                📄 PDF로 저장
                            </button>
                            <button onClick={saveScenario} className="w-full bg-gray-600 text-white py-3 rounded-lg font-medium">
                                💾 시나리오 저장
                            </button>
                        </div>
                    </div>
                    {/* ===== 블로그 배너 ===== */}
                    <a href="https://blog.naver.com/zocdoc" target="_blank" rel="noopener noreferrer" title="블로그 방문하기" className="fixed bottom-5 right-5 z-50 p-3 bg-white rounded-full shadow-lg hover:shadow-xl transition-all transform hover:scale-110">
                        <img src="https://blogpfthumb-phinf.pstatic.net/MjAyMzExMDlfMTY2/MDAxNjk5NTM1OTEzNTY2.eBsibH7tHEJ5FeB3gSWJ3hGqz6mbgqM2TsSKS7c2QRog.CNgc4PQL7zumVLSD72sVI_EB6tsPO_Cwd_LKNj0MiyAg.JPEG.whrekrdl/161.jpg/161.jpg?type=w161" alt="네이버 블로그" className="w-10 h-10"/>
                    </a>
                    <DataTransferModal 
                        isOpen={isExportModalOpen} 
                        onClose={() => setIsExportModalOpen(false)} 
                        onConfirm={handleExport} 
                        type="export"
                        initialSelection={exportSelection}
                    />
                    <DataTransferModal 
                        isOpen={isImportModalOpen} 
                        onClose={() => setIsImportModalOpen(false)} 
                        onConfirm={(selection) => handleImport(selection)} 
                        type="import"
                        initialSelection={importSelection}
                    />
                    </div>
                )
            );
        };
        const ScenarioCompare = ({ scenarios, sectorInfo, calculateMonthlyProjection, formatNumber }) => {
            const { useState, useMemo } = React;
            const [selectedIds, setSelectedIds] = useState([]);
            const toggle = (id) => setSelectedIds(prev => prev.includes(id) ? prev.filter(x=>x!==id) : (prev.length<3 ? [...prev,id] : prev));

            const selected = scenarios.filter(s => selectedIds.includes(s.id)).slice(0,3);
            
            const computeScenarioProjections = (scenarioData) => {
                // Use the main calculation logic to get monthly projections
                const tempAppData = { ...scenarioData }; // Create a temporary appData for calculation
                const monthlyProjections = calculateMonthlyProjection(tempAppData, scenarioData.projectionMonths || 12);
                return monthlyProjections;
            };

            const results = useMemo(() => {
                return selected.map(s => ({
                    id: s.id,
                    name: s.name,
                    data: s.data,
                    projections: computeScenarioProjections(s.data)
                }));
            }, [selected]);

            // Determine common months for comparison
            const allMonths = results.flatMap(r => r.projections.map(p => p.month));
            const uniqueMonths = [...new Set(allMonths)].sort((a, b) => a - b);

            // Limit to max 12 comparison points, adjust for long periods
            const maxComparisonMonths = 12;
            let comparisonInterval = 1;
            if (uniqueMonths.length > maxComparisonMonths) {
                comparisonInterval = Math.ceil(uniqueMonths.length / maxComparisonMonths);
            }
            const displayMonths = uniqueMonths.filter((_, index) => index % comparisonInterval === 0);
            if (!displayMonths.includes(uniqueMonths[uniqueMonths.length - 1])) {
                displayMonths.push(uniqueMonths[uniqueMonths.length - 1]); // Always include the last month
            }


            const getMonthLabel = (monthIndex, baseMonthStr) => {
                try {
                    const [y,m] = (baseMonthStr || new Date().toISOString().slice(0,7)).split('-').map(Number);
                    const d = new Date(y, m - 1 + monthIndex);
                    return `${String(d.getFullYear()).slice(2)}년 ${String(d.getMonth()+1).padStart(2,'0')}월`;
                } catch { return `월 ${monthIndex}`; }
            };

            return (
                <div>
                    <div className="flex flex-wrap gap-2 mb-3">
                        {scenarios.map(s => (
                            <button key={s.id} onClick={() => toggle(s.id)} className={`px-3 py-1 border rounded ${selectedIds.includes(s.id) ? 'bg-blue-50 border-blue-400' : 'hover:bg-gray-50'}`}>{s.name}</button>
                        ))}
                    </div>
                    {results.length > 0 ? (
                        <div className="overflow-x-auto">
                            <table className="w-full text-sm">
                                <thead className="bg-gray-100">
                                    <tr>
                                        <th className="p-3 text-left">섹터/항목</th>
                                        {results.map(r => (<th key={r.id} className="p-3 text-right">{r.name} (최종)</th>))}
                                        {results.length === 2 && (
                                            <th className="p-3 text-right">차이(금액/비중)</th>
                                        )}
                                    </tr>
                                </thead>
                                <tbody>
                                    {Object.keys(sectorInfo).map(sectorKey => (
                                        <React.Fragment key={sectorKey}>
                                            <tr className="border-t">
                                                <td className="p-3 font-semibold">{sectorInfo[sectorKey].icon} {sectorInfo[sectorKey].name}</td>
                                                {results.map(r => {
                                                    const finalProjection = r.projections[r.projections.length - 1];
                                                    const sectorTotal = finalProjection?.sectorTotals[sectorKey] || { amount: 0, percentage: 0 };
                                                    return (
                                                        <td key={r.id} className="p-3 text-right">
                                                            {formatNumber(sectorTotal.amount)} ({(sectorTotal.percentage || 0).toFixed(1)}%)
                                                        </td>
                                                    );
                                                })}
                                                {results.length === 2 && (
                                                    <td className="p-3 text-right text-indigo-700">
                                                        {(() => {
                                                            const finalA = results[0].projections[results[0].projections.length - 1];
                                                            const finalB = results[1].projections[results[1].projections.length - 1];
                                                            const amountA = finalA?.sectorTotals[sectorKey]?.amount || 0;
                                                            const amountB = finalB?.sectorTotals[sectorKey]?.amount || 0;
                                                            const percentA = finalA?.sectorTotals[sectorKey]?.percentage || 0;
                                                            const percentB = finalB?.sectorTotals[sectorKey]?.percentage || 0;
                                                            const diffAmount = amountB - amountA;
                                                            const diffPercent = percentB - percentA;
                                                            const signAmount = diffAmount >= 0 ? '+' : '';
                                                            const signPercent = diffPercent >= 0 ? '+' : '';
                                                            const color = diffAmount >= 0 ? 'text-green-600' : 'text-red-600';
                                                            return (
                                                                <div className={color}>
                                                                    <span>{signAmount}{formatNumber(diffAmount)}</span>
                                                                    <span className="text-xs ml-1">({signPercent}{diffPercent.toFixed(1)}%)</span>
                                                                </div>
                                                            );
                                                        })()}
                                                    </td>
                                                )}
                                            </tr>
                                            {(() => {
                                                // [개선] 모든 시나리오의 자산을 통합하여 고유한 목록 생성 (ID와 이름 모두 사용)
                                                const allItems = new Map(); // key: id, value: { name }
                                                const itemsByName = {}; // key: name, value: { id, name }

                                                results.forEach(r => {
                                                    const finalProjection = r.projections[r.projections.length - 1];
                                                    finalProjection?.itemTotals[sectorKey]?.forEach(item => {
                                                        if (item.id && !allItems.has(item.id)) {
                                                            allItems.set(item.id, { name: item.name });
                                                        }
                                                        if (!itemsByName[item.name]) {
                                                            itemsByName[item.name] = { id: item.id, name: item.name };
                                                        }
                                                    });
                                                });

                                                // ID 기반 목록에 이름 기반 목록을 합치되, 중복 ID는 제외
                                                Object.values(itemsByName).forEach(item => {
                                                    if (!allItems.has(item.id)) {
                                                        // ID가 없는 옛날 데이터거나, ID가 겹치지 않는 이름 기반 항목일 경우
                                                        // 이름으로라도 식별할 수 있도록 추가. (고유성을 위해 이름 사용)
                                                        if (!Array.from(allItems.values()).some(v => v.name === item.name)) {
                                                            allItems.set(item.name, { name: item.name }); // key를 이름으로 사용
                                                        }
                                                    }
                                                });
                                                return Array.from(allItems.entries());
                                            })().map(([id, { name }]) => (
                                                <tr key={`${sectorKey}-${id}`} className="border-t bg-gray-50">
                                                    <td className="p-3 pl-8 text-sm text-gray-600">└ {name}</td>
                                                    {results.map(r => {
                                                        const finalProjection = r.projections[r.projections.length - 1];
                                                        // [개선] ID 우선, 이름 차선으로 정확한 항목 찾기
                                                        const items = finalProjection?.itemTotals[sectorKey] || [];
                                                        const itemData = items.find(item => item.id === id) || items.find(item => item.name === name) || { amount: 0, percentage: 0 };
                                                        return (
                                                            <td key={r.id} className="p-3 text-right text-sm">
                                                                <div>{formatNumber(itemData.amount)}</div>
                                                            </td>
                                                        );
                                                    })}
                                                    {results.length === 2 && (
                                                        <td className="p-3 text-right text-sm text-indigo-700">
                                                            {(() => {
                                                                const finalA = results[0].projections[results[0].projections.length - 1];
                                                                const finalB = results[1].projections[results[1].projections.length - 1];
                                                                // [개선] ID 우선, 이름 차선으로 정확한 항목 찾기
                                                                const itemsA = finalA?.itemTotals[sectorKey] || [];
                                                                const itemsB = finalB?.itemTotals[sectorKey] || [];
                                                                const itemA = itemsA.find(item => item.id === id) || itemsA.find(item => item.name === name) || { amount: 0, percentage: 0 };
                                                                const itemB = itemsB.find(item => item.id === id) || itemsB.find(item => item.name === name) || { amount: 0, percentage: 0 };

                                                                const diffAmount = itemB.amount - itemA.amount;
                                                                const diffPercent = itemB.percentage - itemA.percentage;
                                                                const signAmount = diffAmount >= 0 ? '+' : '';
                                                                const signPercent = diffPercent >= 0 ? '+' : '';
                                                                const color = diffAmount >= 0 ? 'text-green-600' : 'text-red-600';
                                                                return (
                                                                    <div className={color}>
                                                                        <div>{signAmount}{formatNumber(diffAmount)}</div>
                                                                    </div>
                                                                );
                                                            })()}
                                                        </td>
                                                    )}
                                                </tr>
                                            ))
                                            }
                                        </React.Fragment>
                                    ))}
                                    <tr className="border-t-2 border-gray-400 bg-gray-100">
                                        <td className="p-3 font-bold">총계</td>
                                        {results.map(r => {
                                            const finalProjection = r.projections[r.projections.length - 1];
                                            return (
                                                <td key={r.id} className="p-3 text-right font-bold">{formatNumber(finalProjection?.total || 0)}</td>
                                            );
                                        })}
                                        {results.length === 2 && (
                                            <td className="p-3 text-right font-bold text-indigo-700">
                                                {(() => { 
                                                    const finalA = results[0].projections[results[0].projections.length - 1];
                                                    const finalB = results[1].projections[results[1].projections.length - 1];
                                                    const diff = (finalB?.total || 0) - (finalA?.total || 0); 
                                                    const sign = diff >= 0 ? '+' : '';
                                                    const color = diff >= 0 ? 'text-green-600' : 'text-red-600';
                                                    return (
                                                        <div className={color}>{sign}{formatNumber(diff)}</div>
                                                    );
                                                })()}
                                            </td>
                                        )}
                                    </tr>
                                </tbody>
                            </table>

                            {/* Monthly Comparison Table */}
                            <h4 className="text-lg font-semibold text-gray-700 mt-8 mb-4">월별 비교 (최대 12개월)</h4>
                            <table className="w-full text-sm">
                                <thead className="bg-gray-100">
                                    <tr>
                                        <th className="p-3 text-left">월차</th>
                                        {results.map(r => (<th key={r.id} className="p-3 text-right">{r.name} (총자산)</th>))}
                                        {results.length === 2 && (
                                            <th className="p-3 text-right">차이</th>
                                        )}
                                    </tr>
                                </thead>
                                <tbody>
                                    {displayMonths.map(monthIndex => {
                                        const monthLabel = getMonthLabel(monthIndex, results[0]?.data.baseMonth);
                                        return (
                                            <tr key={monthIndex} className="border-t">
                                                <td className="p-3 font-semibold">{monthLabel}</td>
                                                {results.map(r => {
                                                    const projection = r.projections.find(p => p.month === monthIndex);
                                                    return (
                                                        <td key={r.id} className="p-3 text-right">
                                                            {projection ? formatNumber(projection.total) : '-'}
                                                        </td>
                                                    );
                                                })}
                                                {results.length === 2 && (
                                                    <td className="p-3 text-right text-indigo-700">
                                                        {(() => {
                                                            const projA = results[0].projections.find(p => p.month === monthIndex);
                                                            const projB = results[1].projections.find(p => p.month === monthIndex);
                                                            if (projA && projB) {
                                                                const diff = projB.total - projA.total;
                                                                const sign = diff >= 0 ? '+' : '';
                                                                return `${sign}${formatNumber(diff)}`;
                                                            }
                                                            return '-';
                                                        })()}
                                                    </td>
                                                )}
                                            </tr>
                                        );
                                    })}
                                </tbody>
                            </table>
                        </div>
                    ) : (
                        <div className="text-sm text-gray-500">비교할 시나리오를 최대 3개 선택하세요.</div>
                    )}
                </div>
            );
        };

     

        // 에러 바운더리 컴포넌트
        class ErrorBoundary extends React.Component {
            constructor(props) {
                super(props);
                this.state = { hasError: false, error: null };
            }

            static getDerivedStateFromError(error) {
                return { hasError: true, error };
            }

            componentDidCatch(error, errorInfo) {
                console.error('Error caught by boundary:', error, errorInfo);
            }

            render() {
                if (this.state.hasError) {
                    return (
                        <div className="min-h-screen bg-red-50 flex flex-col items-center justify-center gap-4 p-4 text-red-800">
                            <div className="text-center max-w-md bg-white p-8 rounded-lg shadow-lg border border-red-200">
                                <h2 className="text-2xl font-bold mb-2">앗, 문제가 발생했습니다!</h2>
                                <p className="text-sm mb-4 text-gray-600">컴포넌트를 렌더링하는 중 오류가 발생했습니다. 잠시 후 다시 시도해주세요.</p>
                                <button 
                                    onClick={() => this.setState({ hasError: false, error: null })}
                                    className="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600 transition-colors"
                                >
                                    다시 시도
                                </button>
                            </div>
                            {this.state.error && (
                                <details className="text-gray-600 text-xs max-w-md">
                                    <summary className="cursor-pointer">Error details</summary>
                                    <pre className="mt-2 p-2 bg-red-900/20 rounded overflow-auto">
                                        {this.state.error.message}
                                    </pre>
                                </details>
                            )}
                        </div>
                    );
                }

                return this.props.children;
            }
        }

        ReactDOM.createRoot(document.getElementById('root')).render(
            <ErrorBoundary>
                <AssetDashboard />
            </ErrorBoundary>
        );
    </script>
</body>
</html>
